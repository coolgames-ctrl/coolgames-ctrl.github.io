<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cool Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: #fafafa;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    height: 100vh; 
    font-family: 'Courier Prime', monospace;
    user-select: none;
    overflow: hidden;
}

#menuScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: #fafafa;
}

#menuTitle {
    font-size: 52px;
    font-weight: 700;
    color: #222;
    margin-bottom: 60px;
    letter-spacing: -1px;
}

#startButton {
    width: 180px;
    height: 60px;
    background: #222;
    border: none;
    border-radius: 16px;
    font-family: 'Courier Prime', monospace;
    font-size: 18px;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
}

#startButton:hover {
    background: #444;
    transform: scale(1.05);
}

#startButton:active {
    transform: scale(0.98);
}

#gameContainer {
    display: none;
    flex-direction: column;
    align-items: center;
}

#score { 
    color: #222;
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 12px;
    letter-spacing: 8px;
}

canvas { 
    border: 2px solid #222;
    cursor: crosshair;
}

#info { 
    color: #666;
    margin-top: 12px;
    font-size: 13px;
    text-align: center;
    line-height: 1.8;
}
</style>
</head>
<body>

<div id="menuScreen">
    <div id="menuTitle">Cool Games</div>
    <button id="startButton">Start</button>
</div>

<div id="gameContainer">
    <div id="score">0 - 0</div>
    <canvas id="game" width="800" height="450"></canvas>
    <div id="info">A / D = move | W / SPACE = jump | Q = set | CLICK = bump | JUMP + CLICK = spike</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const GROUND_Y = H - 40;
const NET_X = W / 2;
const NET_HEIGHT = 120;
const NET_TOP = GROUND_Y - NET_HEIGHT;
const GRAVITY = 0.32;
const BALL_GRAVITY = 0.20;
const HIT_RANGE = 80;

let playerScore = 0;
let aiScore = 0;
let serveSide = 'player';
let gameState = 'menu';
let roundTimer = 0;

const keys = {};
let clickedThisFrame = false;

// ==================== SOUND EFFECTS ====================
let audioCtx = null;
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;

  switch(type) {
    case 'set':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(500, now);
      osc.frequency.exponentialRampToValueAtTime(700, now + 0.1);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;
    case 'bump':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(500, now + 0.08);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'spike':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now);
      osc.stop(now + 0.18);
      const osc2 = audioCtx.createOscillator();
      const gain2 = audioCtx.createGain();
      osc2.connect(gain2);
      gain2.connect(audioCtx.destination);
      osc2.type = 'square';
      osc2.frequency.setValueAtTime(150, now);
      gain2.gain.setValueAtTime(0.12, now);
      gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc2.start(now);
      osc2.stop(now + 0.1);
      break;
    case 'score':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(523, now);
      osc.frequency.setValueAtTime(659, now + 0.12);
      osc.frequency.setValueAtTime(784, now + 0.24);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.setValueAtTime(0.2, now + 0.3);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      break;
    case 'lose':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.start(now);
      osc.stop(now + 0.4);
      break;
    case 'net':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(180, now);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.start(now);
      osc.stop(now + 0.12);
      break;
    case 'bounce':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(250, now);
      osc.frequency.exponentialRampToValueAtTime(150, now + 0.08);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;
    case 'whistle':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.setValueAtTime(1000, now + 0.1);
      osc.frequency.setValueAtTime(800, now + 0.2);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      osc.start(now);
      osc.stop(now + 0.35);
      break;
  }
}

// ==================== INPUT ====================
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousedown', e => {
  initAudio();
  clickedThisFrame = true;
});

// Menu button handler
const startButton = document.getElementById('startButton');
startButton.addEventListener('click', () => {
  initAudio();
  document.getElementById('menuScreen').style.display = 'none';
  document.getElementById('gameContainer').style.display = 'flex';
  gameState = 'playing';
  playSound('whistle');
  resetRound();
});

// ==================== ENTITIES ====================
const player = {
  x: 150, y: GROUND_Y - 50, w: 50, h: 50,
  vx: 0, vy: 0, speed: 3.2, jumpPower: -7.5,
  onGround: true, color: '#3366ff', facingRight: true
};

const ai = {
  x: W - 200, y: GROUND_Y - 50, w: 50, h: 50,
  vx: 0, vy: 0, speed: 3.0, jumpPower: -7.5,
  onGround: true, color: '#ff4444',
  actionCooldown: 0, hitCount: 0, phase: 'idle'
};

const ball = {
  x: 200, y: 150, r: 14,
  vx: 0, vy: 0, color: '#fff',
  lastHitBy: null
};

// ==================== GAME LOGIC ====================
function resetRound() {
  player.x = 150; player.y = GROUND_Y - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
  ai.x = W - 200; ai.y = GROUND_Y - ai.h; ai.vx = 0; ai.vy = 0; ai.onGround = true;
  ai.actionCooldown = 0;
  ai.hitCount = 0;
  ai.phase = 'idle';

  ball.vy = 0;
  ball.vx = 0;
  ball.lastHitBy = null;
  if (serveSide === 'player') {
    ball.x = 200; ball.y = 130;
  } else {
    ball.x = W - 200; ball.y = 130;
  }
  gameState = 'playing';
  roundTimer = 0;
  document.getElementById('score').textContent = playerScore + ' - ' + aiScore;
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function dist(x1, y1, x2, y2) {
  let dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function ballCenter(rect) {
  return dist(rect.x + rect.w / 2, rect.y + rect.h / 2, ball.x, ball.y);
}

function capBallSpeed(maxSpd) {
  let spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (spd > maxSpd) {
    ball.vx = (ball.vx / spd) * maxSpd;
    ball.vy = (ball.vy / spd) * maxSpd;
  }
}

function doSet(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = 0;
  ball.vy = -8.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  playSound('set');
  return true;
}

function doBump(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 7;
  ball.vy = -7.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  capBallSpeed(11);
  playSound('bump');
  return true;
}

function doSpike(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 7;
  ball.vy = 3.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  capBallSpeed(11);
  playSound('spike');
  return true;
}

function rectCircleCollision(rx, ry, rw, rh, cx, cy, cr) {
  let closestX = clamp(cx, rx, rx + rw);
  let closestY = clamp(cy, ry, ry + rh);
  let dx = cx - closestX, dy = cy - closestY;
  return (dx * dx + dy * dy) < (cr * cr);
}

function pushBallOutOfRect(rect) {
  let closestX = clamp(ball.x, rect.x, rect.x + rect.w);
  let closestY = clamp(ball.y, rect.y, rect.y + rect.h);
  let dx = ball.x - closestX, dy = ball.y - closestY;
  let d = Math.sqrt(dx * dx + dy * dy);
  if (d === 0) { dx = 0; dy = -1; d = 1; }
  let overlap = ball.r - d;
  if (overlap > 0) {
    ball.x += (dx / d) * (overlap + 1);
    ball.y += (dy / d) * (overlap + 1);
  }
}

// ==================== PLAYER ====================
function updatePlayer() {
  player.vx = 0;
  if (keys['a']) { player.vx = -player.speed; player.facingRight = false; }
  if (keys['d']) { player.vx = player.speed; player.facingRight = true; }
  if ((keys['w'] || keys[' ']) && player.onGround) {
    player.vy = player.jumpPower;
    player.onGround = false;
  }

  if (keys['q']) {
    keys['q'] = false;
    doSet(player, 1);
  }

  if (clickedThisFrame) {
    if (!player.onGround) {
      doSpike(player, 1);
    } else {
      doBump(player, 1);
    }
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  if (player.y + player.h >= GROUND_Y) {
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
  }
  player.x = clamp(player.x, 0, NET_X - player.w - 5);
}

// ==================== AI ====================
function updateAI() {
  ai.actionCooldown = Math.max(0, ai.actionCooldown - 1);

  let ballOnMySide = ball.x > NET_X;
  let distToB = ballCenter(ai);

  let predictX = ball.x;
  let predictY = ball.y;
  let pvx = ball.vx;
  let pvy = ball.vy;
  for (let i = 0; i < 60; i++) {
    pvy += BALL_GRAVITY;
    predictX += pvx;
    predictY += pvy;
    if (predictY >= GROUND_Y) break;
  }

  let targetX;
  if (ballOnMySide) {
    if (ball.vy > 0 && ball.y > NET_TOP - 50) {
      targetX = ball.x - ai.w / 2;
    } else {
      targetX = predictX - ai.w / 2;
    }
  } else {
    targetX = W * 0.72 - ai.w / 2;
  }

  targetX = clamp(targetX, NET_X + 5, W - ai.w);

  let diff = targetX - ai.x;
  if (Math.abs(diff) > 5) {
    ai.vx = diff > 0 ? ai.speed : -ai.speed;
  } else {
    ai.vx = 0;
  }

  if (ballOnMySide && ai.actionCooldown <= 0) {
    let ballComingDown = ball.vy > 0;
    let ballNear = distToB < HIT_RANGE + 15;
    let ballAbove = ball.y < ai.y;

    if (ballAbove && ballComingDown && distToB < 140 && ai.onGround) {
      if (ball.y < NET_TOP + 60) {
        ai.vy = ai.jumpPower;
        ai.onGround = false;
      }
    }

    if (ballNear && ballAbove) {
      if (ai.hitCount === 0 && ballComingDown) {
        if (doSet(ai, -1)) {
          ai.actionCooldown = 15;
          ai.hitCount = 1;
        }
      } else if (ai.hitCount >= 1) {
        if (!ai.onGround && ball.y < NET_TOP + 40) {
          if (doSpike(ai, -1)) {
            ai.actionCooldown = 25;
            ai.hitCount = 0;
          }
        } else {
          if (doBump(ai, -1)) {
            ai.actionCooldown = 25;
            ai.hitCount = 0;
          }
        }
      }
    }

    if (ballNear && ballComingDown && ai.actionCooldown <= 0 && ball.y > NET_TOP) {
      if (doBump(ai, -1)) {
        ai.actionCooldown = 25;
        ai.hitCount = 0;
      }
    }
  }

  if (!ballOnMySide) {
    ai.hitCount = 0;
  }

  ai.vy += GRAVITY;
  ai.x += ai.vx;
  ai.y += ai.vy;

  if (ai.y + ai.h >= GROUND_Y) {
    ai.y = GROUND_Y - ai.h;
    ai.vy = 0;
    ai.onGround = true;
  }
  ai.x = clamp(ai.x, NET_X + 5, W - ai.w);
}

// ==================== BALL ====================
function updateBall() {
  ball.vy += BALL_GRAVITY;
  ball.x += ball.vx;
  ball.y += ball.vy;

  capBallSpeed(11);

  if (ball.x - ball.r < 0) {
    ball.x = ball.r;
    ball.vx = Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.x + ball.r > W) {
    ball.x = W - ball.r;
    ball.vx = -Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.y - ball.r < 0) {
    ball.y = ball.r;
    ball.vy = Math.abs(ball.vy) * 0.7;
    playSound('bounce');
  }

  let hitNet = false;
  if (ball.y + ball.r > NET_TOP && ball.y - ball.r < GROUND_Y) {
    if (ball.x - ball.r < NET_X + 4 && ball.x + ball.r > NET_X - 4) {
      hitNet = true;
      if (ball.x < NET_X) {
        ball.x = NET_X - 4 - ball.r;
        ball.vx = -Math.abs(ball.vx) * 0.6;
      } else {
        ball.x = NET_X + 4 + ball.r;
        ball.vx = Math.abs(ball.vx) * 0.6;
      }
    }
  }
  if (ball.x > NET_X - 10 && ball.x < NET_X + 10 && ball.y + ball.r > NET_TOP && ball.y < NET_TOP + 6) {
    ball.y = NET_TOP - ball.r;
    ball.vy = -Math.abs(ball.vy) * 0.5;
    hitNet = true;
  }
  if (hitNet) playSound('net');

  if (rectCircleCollision(player.x, player.y, player.w, player.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(player);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }
  if (rectCircleCollision(ai.x, ai.y, ai.w, ai.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(ai);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }

  if (ball.y + ball.r >= GROUND_Y && gameState === 'playing') {
    gameState = 'roundOver';
    roundTimer = 90;

    if (ball.x < NET_X) {
      aiScore++;
      serveSide = 'player';
      playSound('lose');
    } else {
      playerScore++;
      serveSide = 'ai';
      playSound('score');
    }
    document.getElementById('score').textContent = playerScore + ' - ' + aiScore;
    ball.vy = 0;
    ball.vx = 0;
    ball.y = GROUND_Y - ball.r;
  }
}

// ==================== DRAWING ====================
function drawGame() {
  // Sky
  let grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#87CEEB');
  grad.addColorStop(1, '#d4eef7');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#5a8f3c';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

  // Court line
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 6]);
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(W, GROUND_Y);
  ctx.stroke();
  ctx.setLineDash([]);

  // Net
  ctx.fillStyle = '#333';
  ctx.fillRect(NET_X - 3, NET_TOP, 6, NET_HEIGHT);
  ctx.fillStyle = '#fff';
  ctx.fillRect(NET_X - 6, NET_TOP - 4, 12, 8);
  
  // Net lines
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  for (let ny = NET_TOP + 15; ny < GROUND_Y; ny += 15) {
    ctx.beginPath();
    ctx.moveTo(NET_X - 3, ny);
    ctx.lineTo(NET_X + 3, ny);
    ctx.stroke();
  }

  // Hit range indicator
  let pDist = ballCenter(player);
  if (pDist < HIT_RANGE + 30 && gameState === 'playing') {
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, HIT_RANGE, 0, Math.PI * 2);
    ctx.strokeStyle = pDist < HIT_RANGE ? 'rgba(255,255,100,0.4)' : 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Player shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(player.x + 5, GROUND_Y - 3, player.w - 10, 6);

  // Player (cube)
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  // Eye white
  ctx.fillStyle = '#fff';
  ctx.fillRect(player.x + 30, player.y + 12, 12, 12);
  // Eye pupil
  ctx.fillStyle = '#000';
  ctx.fillRect(player.x + 36, player.y + 16, 4, 4);

  // AI shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(ai.x + 5, GROUND_Y - 3, ai.w - 10, 6);

  // AI (cube)
  ctx.fillStyle = ai.color;
  ctx.fillRect(ai.x, ai.y, ai.w, ai.h);
  ctx.fillStyle = '#fff';
  ctx.fillRect(ai.x + 8, ai.y + 12, 12, 12);
  ctx.fillStyle = '#000';
  ctx.fillRect(ai.x + 10, ai.y + 16, 4, 4);

  // Ball shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(ball.x, GROUND_Y, ball.r * 0.8, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.fillStyle = ball.color;
  ctx.fill();
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  // Ball seam
  ctx.beginPath();
  ctx.moveTo(ball.x - 7, ball.y);
  ctx.quadraticCurveTo(ball.x, ball.y + 7, ball.x + 7, ball.y);
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Labels
  ctx.font = '13px monospace';
  ctx.fillStyle = '#fff';
  ctx.fillText('YOU', player.x + 8, player.y - 8);
  ctx.fillStyle = '#fcc';
  ctx.fillText('AI', ai.x + 16, ai.y - 8);

  // Round over
  if (gameState === 'roundOver') {
    ctx.textAlign = 'center';
    ctx.font = 'bold 28px monospace';

    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(W / 2 - 160, H / 2 - 70, 320, 65);

    if (ball.x < NET_X) {
      ctx.fillStyle = '#ff6666';
      ctx.fillText('AI Scores!', W / 2, H / 2 - 38);
    } else {
      ctx.fillStyle = '#66ff66';
      ctx.fillText('You Score!', W / 2, H / 2 - 38);
    }
    ctx.font = '13px monospace';
    ctx.fillStyle = '#ddd';
    ctx.fillText('next round starting...', W / 2, H / 2 - 16);
    ctx.textAlign = 'left';
  }

  // Action hints
  if (gameState === 'playing' && pDist < HIT_RANGE) {
    ctx.textAlign = 'center';
    ctx.font = '12px monospace';
    ctx.fillStyle = 'rgba(255,255,200,0.9)';
    if (!player.onGround) {
      ctx.fillText('CLICK to SPIKE!', W / 2, H - 8);
    } else {
      ctx.fillText('Q = Set  |  CLICK = Bump', W / 2, H - 8);
    }
    ctx.textAlign = 'left';
  }
}

// ==================== GAME LOOP ====================
function gameLoop() {
  if (gameState === 'menu') {
    // Menu handled by HTML/CSS
  } else if (gameState === 'roundOver') {
    updatePlayer();
    updateBall();
    drawGame();
    roundTimer--;
    if (roundTimer <= 0) {
      playSound('whistle');
      resetRound();
    }
  } else if (gameState === 'playing') {
    updatePlayer();
    updateAI();
    updateBall();
    drawGame();
  }

  clickedThisFrame = false;
  requestAnimationFrame(gameLoop);
}

document.getElementById('score').textContent = '0 - 0';
gameLoop();
</script>
</body>
</html>
