<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cool Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: #fafafa;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    min-height: 100vh; 
    font-family: 'Courier Prime', monospace;
    user-select: none;
    overflow-x: hidden;
    padding: 10px;
}

.screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: #fafafa;
}

#menuScreen { display: flex; }

#menuTitle {
    font-size: 52px;
    font-weight: 700;
    color: #222;
    margin-bottom: 60px;
    letter-spacing: -1px;
}

.menu-button {
    width: 220px;
    height: 50px;
    background: #222;
    border: none;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 8px 0;
}

.menu-button:hover {
    background: #444;
    transform: scale(1.05);
}

.menu-button:active {
    transform: scale(0.98);
}

.menu-button:disabled {
    background: #999;
    cursor: not-allowed;
    transform: none;
}

.menu-button.secondary {
    background: #fff;
    color: #222;
    border: 2px solid #222;
}

.menu-button.secondary:hover {
    background: #222;
    color: #fff;
}

.menu-button.small {
    width: 120px;
    height: 40px;
    font-size: 14px;
}

#lobbyTitle, #waitingTitle, #settingsTitle {
    font-size: 28px;
    font-weight: 700;
    color: #222;
    margin-bottom: 30px;
}

#lobbyInput {
    width: 250px;
    height: 50px;
    border: 2px solid #222;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 18px;
    padding: 0 15px;
    margin-bottom: 20px;
    text-align: center;
    text-transform: uppercase;
    background: #fff;
}

#lobbyInput:focus {
    outline: none;
    border-color: #3366ff;
}

#lobbyStatus, #waitingStatus {
    color: #666;
    margin-top: 20px;
    font-size: 14px;
}

#lobbyCode {
    font-size: 48px;
    font-weight: 700;
    color: #3366ff;
    margin-bottom: 20px;
    letter-spacing: 6px;
    background: #eef4ff;
    padding: 15px 30px;
    border-radius: 12px;
}

.back-button {
    position: absolute;
    top: 30px;
    left: 30px;
    background: none;
    border: 2px solid #222;
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
}

.back-button:hover {
    background: #222;
    color: #fff;
}

.settings-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
}

.radio-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.radio-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 16px;
    background: #fff;
    border: 2px solid #ddd;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    width: 320px;
}

.radio-option:hover {
    border-color: #999;
}

.radio-option.selected {
    border-color: #4CAF50;
    background: #e8f5e9;
}

.radio-circle {
    width: 20px;
    height: 20px;
    border: 2px solid #999;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.radio-option.selected .radio-circle {
    border-color: #4CAF50;
}

.radio-circle::after {
    content: '';
    width: 10px;
    height: 10px;
    background: #4CAF50;
    border-radius: 50%;
    display: none;
}

.radio-option.selected .radio-circle::after {
    display: block;
}

.radio-text {
    flex: 1;
}

.radio-title {
    font-weight: 700;
    font-size: 14px;
}

.radio-desc {
    font-size: 11px;
    color: #666;
    margin-top: 2px;
}

#gameContainer {
    display: none;
    flex-direction: column;
    align-items: center;
    position: relative;
}

#gameHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 1220px;
    margin-bottom: 10px;
}

#gameHeaderLeft {
    display: flex;
    align-items: center;
    gap: 15px;
}

#score { 
    color: #222;
    font-size: 32px;
    font-weight: 700;
    letter-spacing: 8px;
}

#mode-indicator {
    font-size: 14px;
    color: #666;
}

#touchIndicator {
    font-size: 14px;
    color: #666;
    background: #fff;
    padding: 6px 12px;
    border-radius: 8px;
    border: 1px solid #ddd;
}

.game-wrapper {
    display: flex;
    gap: 15px;
}

canvas { 
    border: 2px solid #222;
    cursor: crosshair;
    border-radius: 8px;
}

#chatPanel {
    width: 220px;
    height: 520px;
    background: #fff;
    border: 2px solid #222;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#chatHeader {
    background: #222;
    color: #fff;
    padding: 10px;
    font-size: 14px;
    font-weight: 700;
    text-align: center;
}

#chatMessages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.chat-message {
    padding: 8px 10px;
    border-radius: 8px;
    font-size: 12px;
    word-wrap: break-word;
}

.chat-message.you {
    background: #e3f2fd;
    align-self: flex-end;
    max-width: 85%;
}

.chat-message.opponent {
    background: #ffebee;
    align-self: flex-start;
    max-width: 85%;
}

.chat-message.system {
    background: #f5f5f5;
    align-self: center;
    color: #666;
    font-style: italic;
    text-align: center;
}

#chatInputWrapper {
    display: flex;
    border-top: 2px solid #222;
}

#chatInput {
    flex: 1;
    border: none;
    padding: 10px;
    font-family: 'Courier Prime', monospace;
    font-size: 12px;
    outline: none;
}

#chatSend {
    background: #222;
    color: #fff;
    border: none;
    padding: 10px 15px;
    cursor: pointer;
    font-family: 'Courier Prime', monospace;
    font-weight: 700;
}

#chatSend:hover {
    background: #444;
}

#info { 
    color: #666;
    margin-top: 12px;
    font-size: 13px;
    text-align: center;
    line-height: 1.8;
}

.loading-dots::after {
    content: '';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
}

.error-text { color: #cc3333; }
.success-text { color: #33aa33; }

.mode-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 700;
    margin-left: 10px;
}

.mode-badge.volleyball { background: #e3f2fd; color: #1976d2; }
.mode-badge.tennis { background: #c8e6c9; color: #388e3c; }
.mode-badge.badminton { background: #fff3e0; color: #e65100; }
</style>
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
</head>
<body>

<div id="menuScreen" class="screen">
    <div id="menuTitle">Cool Games</div>
    <button class="menu-button" id="createBtn">Create Lobby</button>
    <button class="menu-button" id="joinBtn">Join Lobby</button>
    <button class="menu-button" id="soloBtn">Play vs AI</button>
    <button class="menu-button secondary" id="settingsBtn">Settings</button>
</div>

<div id="settingsScreen" class="screen">
    <button class="back-button" id="settingsBackBtn">‚Üê Back</button>
    <div id="settingsTitle">Settings</div>
    <div class="settings-container">
        <div style="font-weight: 700; margin-bottom: 5px;">Game Mode:</div>
        <div class="radio-group" id="gameModeGroup">
            <div class="radio-option selected" data-mode="volleyball">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üèê Volleyball</div>
                    <div class="radio-desc">3 touches max, no bounces</div>
                </div>
            </div>
            <div class="radio-option" data-mode="tennis">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üéæ Tennis</div>
                    <div class="radio-desc">1 touch, 1 bounce allowed</div>
                </div>
            </div>
            <div class="radio-option" data-mode="badminton">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üè∏ Badminton</div>
                    <div class="radio-desc">1 touch, no bounces, shuttlecock physics</div>
                </div>
            </div>
        </div>
        <p style="margin-top: 15px; color: #666; font-size: 11px; text-align: center; max-width: 300px;">
            Both players must have the same mode selected to play together.
        </p>
    </div>
</div>

<div id="lobbyScreen" class="screen">
    <button class="back-button" id="lobbyBackBtn">‚Üê Back</button>
    <div id="lobbyTitle">Join Lobby</div>
    <input type="text" id="lobbyInput" placeholder="ENTER CODE" maxlength="8" autocomplete="off" spellcheck="false">
    <button class="menu-button" id="connectBtn">Connect</button>
    <div id="lobbyStatus"></div>
</div>

<div id="waitingScreen" class="screen">
    <button class="back-button" id="waitingBackBtn">‚Üê Back</button>
    <div id="waitingTitle">Your Lobby Code</div>
    <div id="lobbyCode">-----</div>
    <div id="waitingStatus">Waiting for opponent<span class="loading-dots"></span></div>
</div>

<div id="gameContainer">
    <div id="gameHeader">
        <div id="gameHeaderLeft">
            <button class="menu-button small secondary" id="exitGameBtn">‚Üê Menu</button>
            <div id="mode-indicator"></div>
        </div>
        <div id="score">0 - 0</div>
        <div id="touchIndicator"></div>
    </div>
    <div class="game-wrapper">
        <canvas id="game" width="980" height="520"></canvas>
        <div id="chatPanel">
            <div id="chatHeader">Chat</div>
            <div id="chatMessages"></div>
            <div id="chatInputWrapper">
                <input type="text" id="chatInput" placeholder="Type message..." maxlength="100">
                <button id="chatSend">‚Üí</button>
            </div>
        </div>
    </div>
    <div id="info">A / D = move | W / SPACE = jump | Q = set | CLICK = hit | JUMP + CLICK = smash</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const GROUND_Y = H - 50;
const NET_X = W / 2;
const GRAVITY = 0.35;
const HIT_RANGE = 90;
const HAND_SIZE = 12;

// Game settings
let selectedMode = 'volleyball';
let activeMode = 'volleyball';

// Mode-specific settings
const MODES = {
    volleyball: {
        netHeight: 140,
        maxTouches: 3,
        allowBounce: false,
        ballGravity: 0.22,
        ballColor: '#ffffff',
        playerColor: '#3366ff',
        opponentColor: '#ff4444',
        handColor: '#2255dd',
        opponentHandColor: '#dd3333',
        groundColor: '#5a8f3c',
        skyColors: ['#87CEEB', '#d4eef7'],
        ballSize: 16
    },
    tennis: {
        netHeight: 80,
        maxTouches: 1,
        allowBounce: true,
        ballGravity: 0.25,
        ballColor: '#ccff00',
        playerColor: '#2e7d32',
        opponentColor: '#c62828',
        handColor: '#1b5e20',
        opponentHandColor: '#b71c1c',
        groundColor: '#1565c0',
        skyColors: ['#4fc3f7', '#81d4fa'],
        ballSize: 14
    },
    badminton: {
        netHeight: 155,
        maxTouches: 1,
        allowBounce: false,
        ballGravity: 0.12,
        shuttleDrag: 0.992,
        ballColor: '#ffffff',
        playerColor: '#6a1b9a',
        opponentColor: '#00838f',
        handColor: '#4a148c',
        opponentHandColor: '#006064',
        groundColor: '#43a047',
        skyColors: ['#fff8e1', '#ffecb3'],
        ballSize: 12
    }
};

function getModeSettings() {
    return MODES[activeMode];
}

let playerScore = 0;
let opponentScore = 0;
let serveSide = 'player';
let gameState = 'menu';
let roundTimer = 0;
let gameMode = 'solo';
let pointScored = false;

// Touch tracking
let playerTouches = 0;
let opponentTouches = 0;
let lastTouchSide = null;

// Multiplayer
let peer = null;
let conn = null;
let isHost = false;
let lobbyCode = '';
let opponentSelectedMode = 'volleyball';

const keys = {};
let clickedThisFrame = false;
let setPressed = false;
let remoteInput = { left: false, right: false, jump: false, set: false, click: false };

// ==================== CHAT ====================
function addChatMessage(text, type) {
    const messagesDiv = document.getElementById('chatMessages');
    const msg = document.createElement('div');
    msg.className = 'chat-message ' + type;
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (text && conn && conn.open) {
        conn.send({ type: 'chat', message: text });
        addChatMessage(text, 'you');
        input.value = '';
    }
}

document.getElementById('chatSend').addEventListener('click', sendChatMessage);
document.getElementById('chatInput').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        sendChatMessage();
    }
});

// ==================== SOUND EFFECTS ====================
let audioCtx = null;
function initAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
}

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    switch(type) {
        case 'set':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(500, now);
            osc.frequency.exponentialRampToValueAtTime(700, now + 0.1);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;
        case 'hit':
            osc.type = activeMode === 'badminton' ? 'sine' : 'triangle';
            osc.frequency.setValueAtTime(activeMode === 'badminton' ? 800 : 300, now);
            osc.frequency.exponentialRampToValueAtTime(activeMode === 'badminton' ? 400 : 500, now + 0.08);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
            osc.start(now);
            osc.stop(now + 0.15);
            break;
        case 'smash':
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(200, now);
            osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
            gain.gain.setValueAtTime(0.25, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
            osc.start(now);
            osc.stop(now + 0.18);
            break;
        case 'score':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(523, now);
            osc.frequency.setValueAtTime(659, now + 0.12);
            osc.frequency.setValueAtTime(784, now + 0.24);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.setValueAtTime(0.2, now + 0.3);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
            osc.start(now);
            osc.stop(now + 0.5);
            break;
        case 'lose':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
            gain.gain.setValueAtTime(0.2, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
            osc.start(now);
            osc.stop(now + 0.4);
            break;
        case 'fault':
            osc.type = 'square';
            osc.frequency.setValueAtTime(200, now);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.start(now);
            osc.stop(now + 0.3);
            break;
        case 'net':
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(180, now);
            gain.gain.setValueAtTime(0.1, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.12);
            break;
        case 'bounce':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(activeMode === 'tennis' ? 400 : 250, now);
            osc.frequency.exponentialRampToValueAtTime(200, now + 0.08);
            gain.gain.setValueAtTime(0.08, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
            osc.start(now);
            osc.stop(now + 0.1);
            break;
        case 'whistle':
            osc.type = 'sine';
            osc.frequency.setValueAtTime(800, now);
            osc.frequency.setValueAtTime(1000, now + 0.1);
            osc.frequency.setValueAtTime(800, now + 0.2);
            gain.gain.setValueAtTime(0.15, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
            osc.start(now);
            osc.stop(now + 0.35);
            break;
    }
}

// ==================== SCREENS ====================
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById('gameContainer').style.display = 'none';
    if (screenId === 'game') {
        document.getElementById('gameContainer').style.display = 'flex';
    } else {
        document.getElementById(screenId).style.display = 'flex';
    }
}

function exitToMenu() {
    if (confirm('Leave the game?')) {
        cleanupPeer();
        gameState = 'menu';
        showScreen('menuScreen');
    }
}

// ==================== SETTINGS ====================
const gameModeGroup = document.getElementById('gameModeGroup');
gameModeGroup.addEventListener('click', (e) => {
    const option = e.target.closest('.radio-option');
    if (option) {
        document.querySelectorAll('.radio-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedMode = option.dataset.mode;
        localStorage.setItem('gameMode', selectedMode);
    }
});

const savedMode = localStorage.getItem('gameMode');
if (savedMode && MODES[savedMode]) {
    selectedMode = savedMode;
    document.querySelectorAll('.radio-option').forEach(o => {
        o.classList.toggle('selected', o.dataset.mode === selectedMode);
    });
}

// ==================== MULTIPLAYER ====================
function generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    let code = '';
    for (let i = 0; i < 5; i++) {
        code += chars[Math.floor(Math.random() * chars.length)];
    }
    return code;
}

function createLobby() {
    lobbyCode = generateCode();
    document.getElementById('lobbyCode').textContent = lobbyCode;
    document.getElementById('waitingStatus').innerHTML = 'Waiting for opponent<span class="loading-dots"></span>';
    showScreen('waitingScreen');
    
    peer = new Peer('vball-' + lobbyCode);
    
    peer.on('open', (id) => {
        console.log('Lobby created:', id);
    });
    
    peer.on('connection', (connection) => {
        conn = connection;
        isHost = true;
        gameMode = 'host';
        
        conn.on('open', () => {
            setupConnectionHandlers();
        });
        
        conn.on('data', (data) => {
            handleNetworkData(data);
        });
    });
    
    peer.on('error', (err) => {
        if (err.type === 'unavailable-id') {
            document.getElementById('waitingStatus').innerHTML = '<span class="error-text">Code taken, retrying...</span>';
            setTimeout(() => {
                cleanupPeer();
                createLobby();
            }, 1000);
        } else {
            document.getElementById('waitingStatus').innerHTML = '<span class="error-text">Error: ' + err.type + '</span>';
        }
    });
}

function joinLobby() {
    const code = document.getElementById('lobbyInput').value.toUpperCase().trim();
    if (code.length < 3) {
        document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Please enter a valid code</span>';
        return;
    }
    
    document.getElementById('lobbyStatus').innerHTML = 'Connecting<span class="loading-dots"></span>';
    document.getElementById('connectBtn').disabled = true;
    
    peer = new Peer();
    
    peer.on('open', () => {
        conn = peer.connect('vball-' + code, { reliable: true });
        
        conn.on('open', () => {
            isHost = false;
            gameMode = 'client';
            setupConnectionHandlers();
            conn.send({ type: 'ready', selectedMode: selectedMode });
        });
        
        conn.on('data', (data) => {
            handleNetworkData(data);
        });
        
        conn.on('error', (err) => {
            document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Connection failed</span>';
            document.getElementById('connectBtn').disabled = false;
        });
    });
    
    peer.on('error', (err) => {
        document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Lobby not found</span>';
        document.getElementById('connectBtn').disabled = false;
    });
    
    setTimeout(() => {
        if (!conn || !conn.open) {
            document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Connection timeout</span>';
            document.getElementById('connectBtn').disabled = false;
        }
    }, 10000);
}

function setupConnectionHandlers() {
    conn.on('close', () => {
        alert('Opponent disconnected');
        location.reload();
    });
}

function handleNetworkData(data) {
    if (data.type === 'ready' && isHost) {
        opponentSelectedMode = data.selectedMode;
        startMultiplayerGame();
    } else if (data.type === 'start' && !isHost) {
        opponentSelectedMode = data.selectedMode;
        activeMode = (selectedMode === opponentSelectedMode) ? selectedMode : 'volleyball';
        beginGame();
    } else if (data.type === 'state' && !isHost) {
        player.x = W - data.opponent.x - player.w;
        player.y = data.opponent.y;
        player.handAction = data.opponent.handAction || 'idle';
        player.handTimer = data.opponent.handTimer || 0;
        opponent.x = W - data.player.x - opponent.w;
        opponent.y = data.player.y;
        opponent.handAction = data.player.handAction || 'idle';
        opponent.handTimer = data.player.handTimer || 0;
        ball.x = W - data.ball.x;
        ball.y = data.ball.y;
        ball.vx = -data.ball.vx;
        ball.vy = data.ball.vy;
        playerScore = data.opponentScore;
        opponentScore = data.playerScore;
        playerTouches = data.opponentTouches;
        opponentTouches = data.playerTouches;
        gameState = data.gameState;
        updateScoreDisplay();
    } else if (data.type === 'input' && isHost) {
        remoteInput = data.input;
    } else if (data.type === 'sound') {
        playSound(data.sound);
    } else if (data.type === 'chat') {
        addChatMessage(data.message, 'opponent');
    }
}

function sendState() {
    if (conn && conn.open && isHost) {
        conn.send({
            type: 'state',
            player: { x: player.x, y: player.y, handAction: player.handAction, handTimer: player.handTimer },
            opponent: { x: opponent.x, y: opponent.y, handAction: opponent.handAction, handTimer: opponent.handTimer },
            ball: { x: ball.x, y: ball.y, vx: ball.vx, vy: ball.vy },
            playerScore: playerScore,
            opponentScore: opponentScore,
            playerTouches: playerTouches,
            opponentTouches: opponentTouches,
            gameState: gameState
        });
    }
}

function sendInput() {
    if (conn && conn.open && !isHost) {
        conn.send({
            type: 'input',
            input: {
                left: keys['a'],
                right: keys['d'],
                jump: keys['w'] || keys[' '],
                set: setPressed,
                click: clickedThisFrame
            }
        });
    }
}

function startMultiplayerGame() {
    activeMode = (selectedMode === opponentSelectedMode) ? selectedMode : 'volleyball';
    conn.send({ type: 'start', selectedMode: selectedMode });
    beginGame();
}

function beginGame() {
    const mode = getModeSettings();
    let modeText = isHost ? 'üü¢ Hosting' : (gameMode === 'client' ? 'üîµ Connected' : 'vs AI');
    let modeIcon = activeMode === 'volleyball' ? 'üèê' : (activeMode === 'tennis' ? 'üéæ' : 'üè∏');
    let modeBadge = `<span class="mode-badge ${activeMode}">${modeIcon} ${activeMode.toUpperCase()}</span>`;
    document.getElementById('mode-indicator').innerHTML = modeText + ' ' + modeBadge;
    
    document.getElementById('chatMessages').innerHTML = '';
    
    if (gameMode !== 'solo') {
        if (selectedMode !== opponentSelectedMode) {
            addChatMessage(`Mode mismatch! You: ${selectedMode}, Opponent: ${opponentSelectedMode}`, 'system');
            addChatMessage('Defaulting to Volleyball', 'system');
        } else {
            addChatMessage(`Playing ${activeMode}!`, 'system');
        }
        addChatMessage('Game started!', 'system');
    } else {
        addChatMessage(`Playing ${activeMode} vs AI`, 'system');
    }
    
    if (activeMode === 'volleyball') {
        document.getElementById('info').textContent = 'A / D = move | W / SPACE = jump | Q = set | CLICK = bump | JUMP + CLICK = spike';
    } else if (activeMode === 'tennis') {
        document.getElementById('info').textContent = 'A / D = move | W / SPACE = jump | CLICK = hit | JUMP + CLICK = smash';
    } else {
        document.getElementById('info').textContent = 'A / D = move | W / SPACE = jump | CLICK = hit | JUMP + CLICK = smash';
    }
    
    initAudio();
    playSound('whistle');
    showScreen('game');
    gameState = 'playing';
    playerScore = 0;
    opponentScore = 0;
    resetRound();
}

function cleanupPeer() {
    if (conn) conn.close();
    if (peer) peer.destroy();
    conn = null;
    peer = null;
}

// ==================== INPUT ====================
document.addEventListener('keydown', e => {
    if (document.activeElement.tagName === 'INPUT') return;
    
    keys[e.key.toLowerCase()] = true;
    
    if (e.key.toLowerCase() === 'q') setPressed = true;
    if (e.key === 'Escape' && (gameState === 'playing' || gameState === 'roundOver')) exitToMenu();
    if (gameState === 'playing' || gameState === 'roundOver') e.preventDefault();
});

document.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
});

canvas.addEventListener('mousedown', e => {
    initAudio();
    clickedThisFrame = true;
});

document.getElementById('createBtn').addEventListener('click', () => { initAudio(); createLobby(); });
document.getElementById('joinBtn').addEventListener('click', () => {
    initAudio();
    document.getElementById('lobbyStatus').textContent = '';
    document.getElementById('lobbyInput').value = '';
    document.getElementById('connectBtn').disabled = false;
    showScreen('lobbyScreen');
    setTimeout(() => document.getElementById('lobbyInput').focus(), 100);
});
document.getElementById('soloBtn').addEventListener('click', () => {
    initAudio();
    gameMode = 'solo';
    activeMode = selectedMode;
    beginGame();
});
document.getElementById('settingsBtn').addEventListener('click', () => showScreen('settingsScreen'));
document.getElementById('settingsBackBtn').addEventListener('click', () => showScreen('menuScreen'));
document.getElementById('connectBtn').addEventListener('click', () => { initAudio(); joinLobby(); });
document.getElementById('lobbyBackBtn').addEventListener('click', () => { cleanupPeer(); showScreen('menuScreen'); });
document.getElementById('waitingBackBtn').addEventListener('click', () => { cleanupPeer(); showScreen('menuScreen'); });
document.getElementById('exitGameBtn').addEventListener('click', exitToMenu);
document.getElementById('lobbyInput').addEventListener('keypress', (e) => { if (e.key === 'Enter') { initAudio(); joinLobby(); } });

// ==================== ENTITIES ====================
const player = {
    x: 150, y: GROUND_Y - 55, w: 55, h: 55,
    vx: 0, vy: 0, speed: 4, jumpPower: -9,
    onGround: true, facingRight: true,
    handAction: 'idle', handTimer: 0
};

const opponent = {
    x: W - 220, y: GROUND_Y - 55, w: 55, h: 55,
    vx: 0, vy: 0, speed: 3.5, jumpPower: -9,
    onGround: true,
    actionCooldown: 0, hitCount: 0, targetX: W * 0.75,
    personality: 0, lastDecision: 0, mistakeChance: 0,
    pendingAction: null, actionTimer: 0,
    handAction: 'idle', handTimer: 0
};

const ball = {
    x: 200, y: 150, r: 16,
    vx: 0, vy: 0,
    lastHitBy: null, bounceCount: 0
};

// ==================== HAND ANIMATION ====================
function triggerHandAction(entity, action) {
    entity.handAction = action;
    entity.handTimer = action === 'idle' ? 0 : 20;
}

function updateHands(entity) {
    if (entity.handTimer > 0) {
        entity.handTimer--;
        if (entity.handTimer <= 0) {
            entity.handAction = 'idle';
        }
    }
}

function getHandPositions(entity, facingLeft) {
    const cx = entity.x + entity.w / 2;
    const cy = entity.y + entity.h / 2;
    const action = entity.handAction;
    const t = entity.handTimer;
    
    let leftHand = { x: 0, y: 0 };
    let rightHand = { x: 0, y: 0 };
    
    const dir = facingLeft ? -1 : 1;
    
    if (action === 'idle') {
        leftHand = { x: cx - 32 * dir, y: cy + 5 };
        rightHand = { x: cx + 32 * dir, y: cy + 5 };
    } else if (action === 'set') {
        const lift = Math.sin((20 - t) / 20 * Math.PI) * 25;
        leftHand = { x: cx - 15, y: entity.y - 5 - lift };
        rightHand = { x: cx + 15, y: entity.y - 5 - lift };
    } else if (action === 'hit') {
        const swing = Math.sin((20 - t) / 20 * Math.PI);
        leftHand = { x: cx + (25 * dir * swing), y: cy - 10 + swing * 15 };
        rightHand = { x: cx + (35 * dir * swing), y: cy - 5 + swing * 15 };
    } else if (action === 'smash') {
        const phase = (20 - t) / 20;
        if (phase < 0.3) {
            const lift = phase / 0.3;
            leftHand = { x: cx - 10, y: entity.y - 10 - lift * 30 };
            rightHand = { x: cx + 10, y: entity.y - 10 - lift * 30 };
        } else {
            const swing = (phase - 0.3) / 0.7;
            leftHand = { x: cx + (30 * dir * swing), y: entity.y - 40 + swing * 55 };
            rightHand = { x: cx + (40 * dir * swing), y: entity.y - 40 + swing * 55 };
        }
    }
    
    return { left: leftHand, right: rightHand };
}

// ==================== GAME LOGIC ====================
function updateScoreDisplay() {
    document.getElementById('score').textContent = playerScore + ' - ' + opponentScore;
    
    const mode = getModeSettings();
    let touchText = '';
    if (activeMode === 'volleyball') {
        touchText = `Touches: You ${playerTouches}/${mode.maxTouches} | Opp ${opponentTouches}/${mode.maxTouches}`;
    } else if (mode.allowBounce) {
        touchText = `Bounces: ${ball.bounceCount}/1`;
    }
    document.getElementById('touchIndicator').textContent = touchText;
}

function resetRound() {
    const mode = getModeSettings();
    
    player.x = 180; player.y = GROUND_Y - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
    player.handAction = 'idle'; player.handTimer = 0;
    opponent.x = W - 240; opponent.y = GROUND_Y - opponent.h; opponent.vx = 0; opponent.vy = 0; opponent.onGround = true;
    opponent.actionCooldown = 0; opponent.hitCount = 0;
    opponent.personality = Math.random();
    opponent.mistakeChance = 0.08 + Math.random() * 0.07;
    opponent.pendingAction = null; opponent.actionTimer = 0;
    opponent.handAction = 'idle'; opponent.handTimer = 0;

    ball.vy = 0; ball.vx = 0;
    ball.lastHitBy = null; ball.bounceCount = 0;
    ball.r = mode.ballSize;
    
    playerTouches = 0; opponentTouches = 0;
    lastTouchSide = null;
    pointScored = false;
    
    if (serveSide === 'player') {
        ball.x = 220; ball.y = 140;
    } else {
        ball.x = W - 220; ball.y = 140;
    }
    gameState = 'playing';
    roundTimer = 0;
    updateScoreDisplay();
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }
function ballCenter(rect) { return dist(rect.x + rect.w/2, rect.y + rect.h/2, ball.x, ball.y); }

function capBallSpeed(maxSpd) {
    let spd = Math.sqrt(ball.vx**2 + ball.vy**2);
    if (spd > maxSpd) {
        ball.vx = (ball.vx / spd) * maxSpd;
        ball.vy = (ball.vy / spd) * maxSpd;
    }
}

function registerTouch(isPlayer) {
    if (gameState !== 'playing' || pointScored) return false;
    
    const mode = getModeSettings();
    const side = isPlayer ? 'player' : 'opponent';
    
    if (lastTouchSide !== side) {
        if (isPlayer) playerTouches = 1;
        else opponentTouches = 1;
        lastTouchSide = side;
    } else {
        if (isPlayer) playerTouches++;
        else opponentTouches++;
    }
    
    ball.bounceCount = 0;
    updateScoreDisplay();
    
    if (isPlayer && playerTouches > mode.maxTouches) return false;
    if (!isPlayer && opponentTouches > mode.maxTouches) return false;
    
    return true;
}

function doSet(rect, direction) {
    if (gameState !== 'playing' || pointScored) return false;
    if (activeMode !== 'volleyball') return doHit(rect, direction);
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    if (!registerTouch(isPlayer)) {
        scorePoint(!isPlayer);
        playSound('fault');
        return false;
    }
    
    triggerHandAction(rect, 'set');
    ball.vx = direction * 1.5;
    ball.vy = -10;
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    playSound('set');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'set' });
    return true;
}

function doHit(rect, direction) {
    if (gameState !== 'playing' || pointScored) return false;
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    if (!registerTouch(isPlayer)) {
        scorePoint(!isPlayer);
        playSound('fault');
        return false;
    }
    
    triggerHandAction(rect, 'hit');
    
    // Badminton-specific: higher arc and stronger hit
    if (activeMode === 'badminton') {
        ball.vx = direction * 10;
        ball.vy = -9;
    } else {
        ball.vx = direction * 7;
        ball.vy = -8;
    }
    
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    capBallSpeed(activeMode === 'badminton' ? 14 : 12);
    playSound('hit');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'hit' });
    return true;
}

function doSmash(rect, direction) {
    if (gameState !== 'playing' || pointScored) return false;
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    const mode = getModeSettings();
    const netTop = GROUND_Y - mode.netHeight;
    
    if (!registerTouch(isPlayer)) {
        scorePoint(!isPlayer);
        playSound('fault');
        return false;
    }
    
    triggerHandAction(rect, 'smash');
    
    let distToNet = Math.abs(ball.x - NET_X);
    
    // Badminton-specific: steeper angle but still clears net
    if (activeMode === 'badminton') {
        let smashVx = direction * 14;
        // If we're high enough above net, smash down; otherwise hit flat
        let smashVy = ball.y < netTop - 40 ? 4 : -2;
        ball.vx = smashVx;
        ball.vy = smashVy;
    } else {
        let smashVx = direction * (9 + Math.min(distToNet / 50, 3));
        let smashVy = 3 + (ball.y < netTop ? 3 : 1);
        ball.vx = smashVx;
        ball.vy = smashVy;
    }
    
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    capBallSpeed(activeMode === 'badminton' ? 16 : 14);
    playSound('smash');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'smash' });
    return true;
}

function rectCircleCollision(rx, ry, rw, rh, cx, cy, cr) {
    let closestX = clamp(cx, rx, rx + rw);
    let closestY = clamp(cy, ry, ry + rh);
    return dist(cx, cy, closestX, closestY) < cr;
}

function pushBallOutOfRect(rect) {
    let closestX = clamp(ball.x, rect.x, rect.x + rect.w);
    let closestY = clamp(ball.y, rect.y, rect.y + rect.h);
    let dx = ball.x - closestX, dy = ball.y - closestY;
    let d = Math.sqrt(dx*dx + dy*dy);
    if (d === 0) { dx = 0; dy = -1; d = 1; }
    let overlap = ball.r - d;
    if (overlap > 0) {
        ball.x += (dx / d) * (overlap + 1);
        ball.y += (dy / d) * (overlap + 1);
    }
}

// ==================== PLAYER ====================
function updatePlayer() {
    updateHands(player);
    
    player.vx = 0;
    if (keys['a']) { player.vx = -player.speed; player.facingRight = false; }
    if (keys['d']) { player.vx = player.speed; player.facingRight = true; }
    if ((keys['w'] || keys[' ']) && player.onGround) {
        player.vy = player.jumpPower;
        player.onGround = false;
    }

    if (setPressed && activeMode === 'volleyball' && gameState === 'playing') {
        setPressed = false;
        doSet(player, 1);
    }

    if (clickedThisFrame && gameState === 'playing') {
        if (!player.onGround && ball.y < player.y + 20) {
            doSmash(player, 1);
        } else {
            doHit(player, 1);
        }
    }

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    if (player.y + player.h >= GROUND_Y) {
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        player.onGround = true;
    }
    player.x = clamp(player.x, 0, NET_X - player.w - 8);
}

// ==================== OPPONENT ====================
function updateOpponent() {
    updateHands(opponent);
    
    if (gameMode === 'host') {
        opponent.vx = 0;
        if (remoteInput.left) opponent.vx = opponent.speed;
        if (remoteInput.right) opponent.vx = -opponent.speed;
        if (remoteInput.jump && opponent.onGround) {
            opponent.vy = opponent.jumpPower;
            opponent.onGround = false;
        }
        if (remoteInput.set && activeMode === 'volleyball' && gameState === 'playing') {
            remoteInput.set = false;
            doSet(opponent, -1);
        }
        if (remoteInput.click && gameState === 'playing') {
            remoteInput.click = false;
            if (!opponent.onGround && ball.y < opponent.y + 20) {
                doSmash(opponent, -1);
            } else {
                doHit(opponent, -1);
            }
        }
    } else if (gameMode === 'solo') {
        updateAI();
    }

    if (gameMode !== 'client') {
        opponent.vy += GRAVITY;
        opponent.x += opponent.vx;
        opponent.y += opponent.vy;

        if (opponent.y + opponent.h >= GROUND_Y) {
            opponent.y = GROUND_Y - opponent.h;
            opponent.vy = 0;
            opponent.onGround = true;
        }
        opponent.x = clamp(opponent.x, NET_X + 8, W - opponent.w);
    }
}

function updateAI() {
    if (gameState !== 'playing' || pointScored) {
        opponent.vx = 0;
        opponent.pendingAction = null;
        opponent.actionTimer = 0;
        return;
    }
    
    const mode = getModeSettings();
    const netTop = GROUND_Y - mode.netHeight;
    
    opponent.actionCooldown = Math.max(0, opponent.actionCooldown - 1);
    opponent.lastDecision++;

    let ballOnMySide = ball.x > NET_X;
    let distToB = ballCenter(opponent);

    // Predict landing
    let predictX = ball.x, predictY = ball.y;
    let pvx = ball.vx, pvy = ball.vy;
    for (let i = 0; i < 80; i++) {
        pvy += mode.ballGravity;
        if (activeMode === 'badminton') pvx *= mode.shuttleDrag;
        predictX += pvx;
        predictY += pvy;
        if (predictY >= GROUND_Y - 20) break;
    }

    if (opponent.lastDecision > 25 + Math.random() * 15) {
        opponent.lastDecision = 0;
        
        if (Math.random() < opponent.mistakeChance) {
            opponent.targetX = opponent.x + (Math.random() - 0.5) * 100;
        } else if (ballOnMySide) {
            if (opponent.personality < 0.3) {
                opponent.targetX = ball.x - opponent.w / 2 + (Math.random() - 0.5) * 30;
            } else if (opponent.personality < 0.7) {
                opponent.targetX = predictX - opponent.w / 2 + (Math.random() - 0.5) * 20;
            } else {
                opponent.targetX = Math.max(predictX - opponent.w / 2, W * 0.65);
            }
        } else {
            opponent.targetX = W * (0.7 + opponent.personality * 0.1) - opponent.w / 2;
        }
    }

    opponent.targetX = clamp(opponent.targetX, NET_X + 12, W - opponent.w - 12);

    let diff = opponent.targetX - opponent.x;
    if (Math.abs(diff) > 8 + Math.random() * 5) {
        opponent.vx = (diff > 0 ? opponent.speed : -opponent.speed) * (0.85 + Math.random() * 0.3);
    } else {
        opponent.vx = 0;
    }

    // Handle pending action
    if (opponent.pendingAction && opponent.actionTimer > 0) {
        opponent.actionTimer--;
        if (opponent.actionTimer <= 0 && gameState === 'playing' && !pointScored) {
            let action = opponent.pendingAction;
            opponent.pendingAction = null;
            
            if (action === 'jump' && opponent.onGround) {
                opponent.vy = opponent.jumpPower * (0.9 + Math.random() * 0.2);
                opponent.onGround = false;
            } else if (action === 'smash') {
                if (doSmash(opponent, -1)) {
                    opponent.actionCooldown = 18 + Math.floor(Math.random() * 10);
                    opponent.hitCount = 0;
                }
            } else if (action === 'set') {
                if (doSet(opponent, -1)) {
                    opponent.actionCooldown = 10 + Math.floor(Math.random() * 6);
                    opponent.hitCount = 1;
                }
            } else if (action === 'hit') {
                if (doHit(opponent, -1)) {
                    opponent.actionCooldown = 15 + Math.floor(Math.random() * 10);
                    opponent.hitCount = 0;
                }
            }
        }
    }

    // Decision making
    if (ballOnMySide && opponent.actionCooldown <= 0 && !opponent.pendingAction) {
        let ballComingDown = ball.vy > 0;
        let ballNear = distToB < HIT_RANGE + 25;
        let ballAbove = ball.y < opponent.y;
        let ballHigh = ball.y < netTop - 20;

        if (ballAbove && ballComingDown && distToB < 180 && opponent.onGround) {
            if (ball.y < netTop + 100 && Math.random() > 0.15 && !opponent.pendingAction) {
                opponent.pendingAction = 'jump';
                opponent.actionTimer = Math.floor(Math.random() * 6) + 1;
            }
        }

        if (ballNear && (ballAbove || ball.y < opponent.y + 30) && !opponent.pendingAction) {
            if (!opponent.onGround && ballHigh && ball.y < opponent.y + 40) {
                if (Math.random() > 0.2) {
                    opponent.pendingAction = 'smash';
                    opponent.actionTimer = Math.floor(Math.random() * 4) + 1;
                }
            } else if (activeMode === 'volleyball' && opponent.hitCount === 0 && ballComingDown) {
                if (Math.random() > 0.3) {
                    opponent.pendingAction = 'set';
                    opponent.actionTimer = Math.floor(Math.random() * 4) + 1;
                }
            } else if (ballComingDown) {
                opponent.pendingAction = 'hit';
                opponent.actionTimer = Math.floor(Math.random() * 4) + 1;
            }
        }

        if (ballNear && ball.y > netTop + 50 && ballComingDown && !opponent.pendingAction) {
            opponent.pendingAction = 'hit';
            opponent.actionTimer = 1;
        }
    }

    if (!ballOnMySide) {
        opponent.hitCount = 0;
        opponent.pendingAction = null;
        opponent.actionTimer = 0;
    }
}

// ==================== BALL ====================
function updateBall() {
    if (gameMode === 'client') return;
    if (gameState !== 'playing') return;
    if (pointScored) return;

    const mode = getModeSettings();
    const netTop = GROUND_Y - mode.netHeight;

    ball.vy += mode.ballGravity;
    if (activeMode === 'badminton') {
        ball.vx *= mode.shuttleDrag;
    }
    ball.x += ball.vx;
    ball.y += ball.vy;

    capBallSpeed(16);

    // Walls
    if (ball.x - ball.r < 0) {
        ball.x = ball.r;
        ball.vx = Math.abs(ball.vx) * 0.7;
        playSound('bounce');
    }
    if (ball.x + ball.r > W) {
        ball.x = W - ball.r;
        ball.vx = -Math.abs(ball.vx) * 0.7;
        playSound('bounce');
    }
    if (ball.y - ball.r < 0) {
        ball.y = ball.r;
        ball.vy = Math.abs(ball.vy) * 0.7;
        playSound('bounce');
    }

    // Net
    let hitNet = false;
    if (ball.y + ball.r > netTop && ball.y - ball.r < GROUND_Y) {
        if (ball.x - ball.r < NET_X + 5 && ball.x + ball.r > NET_X - 5) {
            hitNet = true;
            if (ball.x < NET_X) {
                ball.x = NET_X - 5 - ball.r;
                ball.vx = -Math.abs(ball.vx) * 0.5;
            } else {
                ball.x = NET_X + 5 + ball.r;
                ball.vx = Math.abs(ball.vx) * 0.5;
            }
        }
    }
    if (ball.x > NET_X - 12 && ball.x < NET_X + 12 && ball.y + ball.r > netTop && ball.y < netTop + 8) {
        ball.y = netTop - ball.r;
        ball.vy = -Math.abs(ball.vy) * 0.4;
        hitNet = true;
    }
    if (hitNet) playSound('net');

    // Track side crossings
    let currentSide = ball.x < NET_X ? 'player' : 'opponent';
    if (lastTouchSide && currentSide !== lastTouchSide) {
        if (currentSide === 'player') playerTouches = 0;
        else opponentTouches = 0;
        updateScoreDisplay();
    }

    // Player collisions
    if (rectCircleCollision(player.x, player.y, player.w, player.h, ball.x, ball.y, ball.r)) {
        pushBallOutOfRect(player);
        ball.vy = Math.min(ball.vy, -2);
        playSound('bounce');
    }
    if (rectCircleCollision(opponent.x, opponent.y, opponent.w, opponent.h, ball.x, ball.y, ball.r)) {
        pushBallOutOfRect(opponent);
        ball.vy = Math.min(ball.vy, -2);
        playSound('bounce');
    }

    // Ground
    if (ball.y + ball.r >= GROUND_Y) {
        if (mode.allowBounce && ball.bounceCount < 1) {
            ball.bounceCount++;
            ball.y = GROUND_Y - ball.r;
            ball.vy = -ball.vy * 0.55;
            ball.vx *= 0.75;
            playSound('bounce');
            updateScoreDisplay();
        } else {
            scorePoint(ball.x >= NET_X);
        }
    }
}

function scorePoint(playerScored) {
    if (pointScored || gameState !== 'playing') return;
    
    pointScored = true;
    gameState = 'roundOver';
    roundTimer = 100;
    ball.vy = 0; ball.vx = 0;
    ball.y = Math.min(ball.y, GROUND_Y - ball.r);

    if (playerScored) {
        playerScore++;
        serveSide = 'opponent';
        playSound('score');
    } else {
        opponentScore++;
        serveSide = 'player';
        playSound('lose');
    }
    updateScoreDisplay();
}

// ==================== DRAWING ====================
function drawPlayer(entity, mode, facingLeft, label) {
    const hands = getHandPositions(entity, facingLeft);
    const handColor = entity === player ? mode.handColor : mode.opponentHandColor;
    const bodyColor = entity === player ? mode.playerColor : mode.opponentColor;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(entity.x + entity.w/2, GROUND_Y + 2, entity.w * 0.4, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Hands (behind body for some positions)
    ctx.fillStyle = handColor;
    if (entity.handAction === 'set' || (entity.handAction === 'smash' && entity.handTimer > 14)) {
        ctx.fillRect(hands.left.x - HAND_SIZE/2, hands.left.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
        ctx.fillRect(hands.right.x - HAND_SIZE/2, hands.right.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
    }
    
    // Body
    ctx.fillStyle = bodyColor;
    ctx.fillRect(entity.x, entity.y, entity.w, entity.h);
    
    // Eye
    ctx.fillStyle = '#fff';
    if (facingLeft) {
        ctx.fillRect(entity.x + 9, entity.y + 14, 14, 14);
        ctx.fillStyle = '#000';
        ctx.fillRect(entity.x + 12, entity.y + 18, 5, 5);
    } else {
        ctx.fillRect(entity.x + 32, entity.y + 14, 14, 14);
        ctx.fillStyle = '#000';
        ctx.fillRect(entity.x + 38, entity.y + 18, 5, 5);
    }
    
    // Hands (in front for other positions)
    ctx.fillStyle = handColor;
    if (entity.handAction !== 'set' && !(entity.handAction === 'smash' && entity.handTimer > 14)) {
        ctx.fillRect(hands.left.x - HAND_SIZE/2, hands.left.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
        ctx.fillRect(hands.right.x - HAND_SIZE/2, hands.right.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
    }
    
    // Label
    ctx.font = 'bold 14px monospace';
    ctx.fillStyle = entity === player ? '#fff' : '#fdd';
    ctx.fillText(label, entity.x + (facingLeft ? 16 : 8), entity.y - 10);
}

function drawGame() {
    const mode = getModeSettings();
    const netTop = GROUND_Y - mode.netHeight;

    // Sky
    let grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, mode.skyColors[0]);
    grad.addColorStop(1, mode.skyColors[1]);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Ground
    ctx.fillStyle = mode.groundColor;
    ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
    
    // Court markings
    if (activeMode === 'tennis') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(30, GROUND_Y);
        ctx.lineTo(W - 30, GROUND_Y);
        ctx.stroke();
    } else if (activeMode === 'badminton') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(50, GROUND_Y, W - 100, 50);
        ctx.beginPath();
        ctx.moveTo(NET_X, GROUND_Y);
        ctx.lineTo(NET_X, GROUND_Y + 50);
        ctx.stroke();
    } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y);
        ctx.lineTo(W, GROUND_Y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Net
    ctx.fillStyle = activeMode === 'badminton' ? '#555' : '#333';
    ctx.fillRect(NET_X - 4, netTop, 8, mode.netHeight);
    ctx.fillStyle = '#fff';
    ctx.fillRect(NET_X - 8, netTop - 5, 16, 10);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    for (let ny = netTop + 12; ny < GROUND_Y; ny += 12) {
        ctx.beginPath();
        ctx.moveTo(NET_X - 4, ny);
        ctx.lineTo(NET_X + 4, ny);
        ctx.stroke();
    }

    // Hit range indicator
    let pDist = ballCenter(player);
    if (pDist < HIT_RANGE + 30 && gameState === 'playing') {
        ctx.beginPath();
        ctx.arc(player.x + player.w/2, player.y + player.h/2, HIT_RANGE, 0, Math.PI * 2);
        ctx.strokeStyle = pDist < HIT_RANGE ? 'rgba(255,255,100,0.4)' : 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Draw players with hands
    drawPlayer(player, mode, false, 'YOU');
    drawPlayer(opponent, mode, true, gameMode === 'solo' ? 'AI' : 'P2');

    // Ball shadow
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.beginPath();
    ctx.ellipse(ball.x, GROUND_Y + 2, ball.r * 0.7, 4, 0, 0, Math.PI * 2);
    ctx.fill();

    // Ball / Shuttlecock
    if (activeMode === 'badminton') {
        let angle = Math.atan2(ball.vy, ball.vx);
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(angle);
        
        ctx.fillStyle = '#f5f5dc';
        ctx.beginPath();
        ctx.arc(0, 0, ball.r * 0.7, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(-ball.r * 0.5, 0);
        ctx.lineTo(-ball.r * 2.2, -ball.r * 1.1);
        ctx.lineTo(-ball.r * 2.2, ball.r * 1.1);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        ctx.restore();
    } else {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = mode.ballColor;
        ctx.fill();
        
        if (activeMode === 'tennis') {
            ctx.strokeStyle = '#9acd32';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r * 0.55, -0.6, Math.PI + 0.6);
            ctx.stroke();
        } else {
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1.5;
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ball.x - ball.r * 0.5, ball.y);
            ctx.quadraticCurveTo(ball.x, ball.y + ball.r * 0.5, ball.x + ball.r * 0.5, ball.y);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            ctx.stroke();
        }
    }

    // Bounce indicator
    if (activeMode === 'tennis' && ball.bounceCount === 1 && gameState === 'playing') {
        ctx.textAlign = 'center';
        ctx.font = 'bold 14px monospace';
        ctx.fillStyle = '#ff6600';
        ctx.fillText('BOUNCE!', ball.x, ball.y - 28);
        ctx.textAlign = 'left';
    }

    // Round over
    if (gameState === 'roundOver') {
        ctx.textAlign = 'center';
        ctx.font = 'bold 32px monospace';
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(W/2 - 180, H/2 - 80, 360, 75);

        if (ball.x < NET_X) {
            ctx.fillStyle = '#ff7777';
            ctx.fillText(gameMode === 'solo' ? 'AI Scores!' : 'P2 Scores!', W/2, H/2 - 42);
        } else {
            ctx.fillStyle = '#77ff77';
            ctx.fillText('You Score!', W/2, H/2 - 42);
        }
        ctx.font = '14px monospace';
        ctx.fillStyle = '#ddd';
        ctx.fillText('next round starting...', W/2, H/2 - 16);
        ctx.textAlign = 'left';
    }

    // Action hints
    if (gameState === 'playing' && pDist < HIT_RANGE) {
        ctx.textAlign = 'center';
        ctx.font = '13px monospace';
        ctx.fillStyle = 'rgba(255,255,220,0.95)';
        if (!player.onGround) {
            ctx.fillText('CLICK to SMASH!', W/2, H - 12);
        } else if (activeMode === 'volleyball') {
            ctx.fillText('Q = Set  |  CLICK = Bump', W/2, H - 12);
        } else {
            ctx.fillText('CLICK = Hit', W/2, H - 12);
        }
        ctx.textAlign = 'left';
    }
}

// ==================== GAME LOOP ====================
let lastTime = 0;
const TICK_RATE = 1000 / 60;

function gameLoop(timestamp) {
    if (timestamp - lastTime >= TICK_RATE) {
        lastTime = timestamp;

        if (gameState === 'playing' || gameState === 'roundOver') {
            updatePlayer();
            updateOpponent();
            updateBall();
            drawGame();

            if (gameMode === 'host') sendState();
            else if (gameMode === 'client') sendInput();

            if (gameState === 'roundOver') {
                roundTimer--;
                if (roundTimer <= 0) {
                    playSound('whistle');
                    resetRound();
                }
            }
        }

        clickedThisFrame = false;
        setPressed = false;
    }

    requestAnimationFrame(gameLoop);
}

document.getElementById('score').textContent = '0 - 0';
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
