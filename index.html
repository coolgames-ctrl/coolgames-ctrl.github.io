<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cool Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: #fafafa;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    height: 100vh; 
    font-family: 'Courier Prime', monospace;
    user-select: none;
    overflow: hidden;
}

.screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: #fafafa;
}

#menuScreen { display: flex; }

#menuTitle {
    font-size: 52px;
    font-weight: 700;
    color: #222;
    margin-bottom: 60px;
    letter-spacing: -1px;
}

.menu-button {
    width: 220px;
    height: 50px;
    background: #222;
    border: none;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 8px 0;
}

.menu-button:hover {
    background: #444;
    transform: scale(1.05);
}

.menu-button:active {
    transform: scale(0.98);
}

.menu-button:disabled {
    background: #999;
    cursor: not-allowed;
    transform: none;
}

#lobbyTitle, #waitingTitle {
    font-size: 28px;
    font-weight: 700;
    color: #222;
    margin-bottom: 30px;
}

#lobbyInput {
    width: 250px;
    height: 50px;
    border: 2px solid #222;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 18px;
    padding: 0 15px;
    margin-bottom: 20px;
    text-align: center;
    text-transform: uppercase;
}

#lobbyInput:focus {
    outline: none;
    border-color: #3366ff;
}

#lobbyStatus, #waitingStatus {
    color: #666;
    margin-top: 20px;
    font-size: 14px;
}

#lobbyCode {
    font-size: 48px;
    font-weight: 700;
    color: #3366ff;
    margin-bottom: 20px;
    letter-spacing: 6px;
    background: #eef4ff;
    padding: 15px 30px;
    border-radius: 12px;
}

.back-button {
    position: absolute;
    top: 30px;
    left: 30px;
    background: none;
    border: 2px solid #222;
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
}

.back-button:hover {
    background: #222;
    color: #fff;
}

#gameContainer {
    display: none;
    flex-direction: column;
    align-items: center;
}

#score { 
    color: #222;
    font-size: 28px;
    font-weight: 700;
    margin-bottom: 12px;
    letter-spacing: 8px;
}

#mode-indicator {
    font-size: 14px;
    color: #666;
    margin-bottom: 8px;
}

canvas { 
    border: 2px solid #222;
    cursor: crosshair;
}

#info { 
    color: #666;
    margin-top: 12px;
    font-size: 13px;
    text-align: center;
    line-height: 1.8;
}

.loading-dots::after {
    content: '';
    animation: dots 1.5s infinite;
}

@keyframes dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
}
</style>
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
</head>
<body>

<div id="menuScreen" class="screen">
    <div id="menuTitle">Cool Games</div>
    <button class="menu-button" id="createBtn">Create Lobby</button>
    <button class="menu-button" id="joinBtn">Join Lobby</button>
    <button class="menu-button" id="soloBtn">Play vs AI</button>
</div>

<div id="lobbyScreen" class="screen">
    <button class="back-button" id="lobbyBackBtn">‚Üê Back</button>
    <div id="lobbyTitle">Join Lobby</div>
    <input type="text" id="lobbyInput" placeholder="ENTER CODE" maxlength="8">
    <button class="menu-button" id="connectBtn">Connect</button>
    <div id="lobbyStatus"></div>
</div>

<div id="waitingScreen" class="screen">
    <button class="back-button" id="waitingBackBtn">‚Üê Back</button>
    <div id="waitingTitle">Your Lobby Code</div>
    <div id="lobbyCode">-----</div>
    <div id="waitingStatus">Waiting for opponent<span class="loading-dots"></span></div>
</div>

<div id="gameContainer">
    <div id="mode-indicator"></div>
    <div id="score">0 - 0</div>
    <canvas id="game" width="800" height="450"></canvas>
    <div id="info">A / D = move | W / SPACE = jump | Q = set | CLICK = bump | JUMP + CLICK = spike</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const GROUND_Y = H - 40;
const NET_X = W / 2;
const NET_HEIGHT = 120;
const NET_TOP = GROUND_Y - NET_HEIGHT;
const GRAVITY = 0.32;
const BALL_GRAVITY = 0.20;
const HIT_RANGE = 80;

let playerScore = 0;
let opponentScore = 0;
let serveSide = 'player';
let gameState = 'menu';
let roundTimer = 0;
let gameMode = 'solo'; // 'solo', 'host', 'client'

// Multiplayer
let peer = null;
let conn = null;
let isHost = false;
let lobbyCode = '';

const keys = {};
let clickedThisFrame = false;

// ==================== SOUND EFFECTS ====================
let audioCtx = null;
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;

  switch(type) {
    case 'set':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(500, now);
      osc.frequency.exponentialRampToValueAtTime(700, now + 0.1);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;
    case 'bump':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(500, now + 0.08);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'spike':
      osc.type = 'sawtooth';
      osc.frequency.setValueAtTime(200, now);
      osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
      gain.gain.setValueAtTime(0.25, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now);
      osc.stop(now + 0.18);
      break;
    case 'score':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(523, now);
      osc.frequency.setValueAtTime(659, now + 0.12);
      osc.frequency.setValueAtTime(784, now + 0.24);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.setValueAtTime(0.2, now + 0.3);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      break;
    case 'lose':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
      osc.start(now);
      osc.stop(now + 0.4);
      break;
    case 'net':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(180, now);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.start(now);
      osc.stop(now + 0.12);
      break;
    case 'bounce':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(250, now);
      osc.frequency.exponentialRampToValueAtTime(150, now + 0.08);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;
    case 'whistle':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.setValueAtTime(1000, now + 0.1);
      osc.frequency.setValueAtTime(800, now + 0.2);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      osc.start(now);
      osc.stop(now + 0.35);
      break;
  }
}

// ==================== SCREENS ====================
function showScreen(screenId) {
  document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
  document.getElementById('gameContainer').style.display = 'none';
  if (screenId === 'game') {
    document.getElementById('gameContainer').style.display = 'flex';
  } else {
    document.getElementById(screenId).style.display = 'flex';
  }
}

// ==================== MULTIPLAYER ====================
function generateCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) {
    code += chars[Math.floor(Math.random() * chars.length)];
  }
  return code;
}

function createLobby() {
  lobbyCode = generateCode();
  document.getElementById('lobbyCode').textContent = lobbyCode;
  showScreen('waitingScreen');
  
  peer = new Peer('vball-' + lobbyCode);
  
  peer.on('open', (id) => {
    console.log('Lobby created:', id);
  });
  
  peer.on('connection', (connection) => {
    conn = connection;
    isHost = true;
    gameMode = 'host';
    setupConnection();
  });
  
  peer.on('error', (err) => {
    console.error('Peer error:', err);
    document.getElementById('waitingStatus').textContent = 'Error: ' + err.type;
  });
}

function joinLobby() {
  const code = document.getElementById('lobbyInput').value.toUpperCase().trim();
  if (code.length < 3) {
    document.getElementById('lobbyStatus').textContent = 'Please enter a valid code';
    return;
  }
  
  document.getElementById('lobbyStatus').textContent = 'Connecting...';
  document.getElementById('connectBtn').disabled = true;
  
  peer = new Peer();
  
  peer.on('open', () => {
    conn = peer.connect('vball-' + code);
    
    conn.on('open', () => {
      isHost = false;
      gameMode = 'client';
      setupConnection();
    });
    
    conn.on('error', (err) => {
      document.getElementById('lobbyStatus').textContent = 'Failed to connect';
      document.getElementById('connectBtn').disabled = false;
    });
  });
  
  peer.on('error', (err) => {
    document.getElementById('lobbyStatus').textContent = 'Lobby not found';
    document.getElementById('connectBtn').disabled = false;
  });
  
  setTimeout(() => {
    if (!conn || !conn.open) {
      document.getElementById('lobbyStatus').textContent = 'Connection timeout';
      document.getElementById('connectBtn').disabled = false;
    }
  }, 10000);
}

function setupConnection() {
  conn.on('data', (data) => {
    handleNetworkData(data);
  });
  
  conn.on('close', () => {
    alert('Opponent disconnected');
    location.reload();
  });
  
  if (isHost) {
    startMultiplayerGame();
  }
}

function handleNetworkData(data) {
  if (data.type === 'start') {
    startMultiplayerGame();
  } else if (data.type === 'state' && !isHost) {
    // Client receives state from host
    player.x = W - data.opponent.x - player.w;
    player.y = data.opponent.y;
    opponent.x = W - data.player.x - opponent.w;
    opponent.y = data.player.y;
    ball.x = W - data.ball.x;
    ball.y = data.ball.y;
    ball.vx = -data.ball.vx;
    ball.vy = data.ball.vy;
    playerScore = data.opponentScore;
    opponentScore = data.playerScore;
    gameState = data.gameState;
    document.getElementById('score').textContent = playerScore + ' - ' + opponentScore;
  } else if (data.type === 'input' && isHost) {
    // Host receives input from client
    remoteInput = data.input;
  }
}

function sendState() {
  if (conn && conn.open && isHost) {
    conn.send({
      type: 'state',
      player: { x: player.x, y: player.y },
      opponent: { x: opponent.x, y: opponent.y },
      ball: { x: ball.x, y: ball.y, vx: ball.vx, vy: ball.vy },
      playerScore: playerScore,
      opponentScore: opponentScore,
      gameState: gameState
    });
  }
}

function sendInput() {
  if (conn && conn.open && !isHost) {
    conn.send({
      type: 'input',
      input: {
        left: keys['a'],
        right: keys['d'],
        jump: keys['w'] || keys[' '],
        set: keys['q'],
        click: clickedThisFrame
      }
    });
  }
}

let remoteInput = { left: false, right: false, jump: false, set: false, click: false };

function startMultiplayerGame() {
  if (isHost) {
    conn.send({ type: 'start' });
  }
  document.getElementById('mode-indicator').textContent = isHost ? 'üü¢ Hosting' : 'üîµ Connected';
  initAudio();
  playSound('whistle');
  showScreen('game');
  gameState = 'playing';
  resetRound();
}

function cleanupPeer() {
  if (conn) conn.close();
  if (peer) peer.destroy();
  conn = null;
  peer = null;
}

// ==================== INPUT ====================
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousedown', e => {
  initAudio();
  clickedThisFrame = true;
});

// Menu buttons
document.getElementById('createBtn').addEventListener('click', () => {
  initAudio();
  createLobby();
});

document.getElementById('joinBtn').addEventListener('click', () => {
  initAudio();
  showScreen('lobbyScreen');
});

document.getElementById('soloBtn').addEventListener('click', () => {
  initAudio();
  gameMode = 'solo';
  document.getElementById('mode-indicator').textContent = 'vs AI';
  playSound('whistle');
  showScreen('game');
  gameState = 'playing';
  resetRound();
});

document.getElementById('connectBtn').addEventListener('click', () => {
  initAudio();
  joinLobby();
});

document.getElementById('lobbyBackBtn').addEventListener('click', () => {
  showScreen('menuScreen');
});

document.getElementById('waitingBackBtn').addEventListener('click', () => {
  cleanupPeer();
  showScreen('menuScreen');
});

document.getElementById('lobbyInput').addEventListener('keypress', (e) => {
  if (e.key === 'Enter') {
    initAudio();
    joinLobby();
  }
});

// ==================== ENTITIES ====================
const player = {
  x: 150, y: GROUND_Y - 50, w: 50, h: 50,
  vx: 0, vy: 0, speed: 3.5, jumpPower: -8,
  onGround: true, color: '#3366ff', facingRight: true
};

const opponent = {
  x: W - 200, y: GROUND_Y - 50, w: 50, h: 50,
  vx: 0, vy: 0, speed: 3.2, jumpPower: -8,
  onGround: true, color: '#ff4444',
  // AI specific
  actionCooldown: 0, hitCount: 0, targetX: W * 0.75,
  personality: 0, lastDecision: 0, mistakeChance: 0
};

const ball = {
  x: 200, y: 150, r: 14,
  vx: 0, vy: 0, color: '#fff',
  lastHitBy: null
};

// ==================== GAME LOGIC ====================
function resetRound() {
  player.x = 150; player.y = GROUND_Y - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
  opponent.x = W - 200; opponent.y = GROUND_Y - opponent.h; opponent.vx = 0; opponent.vy = 0; opponent.onGround = true;
  opponent.actionCooldown = 0;
  opponent.hitCount = 0;
  opponent.personality = Math.random();
  opponent.mistakeChance = 0.08 + Math.random() * 0.07;

  ball.vy = 0;
  ball.vx = 0;
  ball.lastHitBy = null;
  if (serveSide === 'player') {
    ball.x = 200; ball.y = 130;
  } else {
    ball.x = W - 200; ball.y = 130;
  }
  gameState = 'playing';
  roundTimer = 0;
  document.getElementById('score').textContent = playerScore + ' - ' + opponentScore;
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function dist(x1, y1, x2, y2) {
  let dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function ballCenter(rect) {
  return dist(rect.x + rect.w / 2, rect.y + rect.h / 2, ball.x, ball.y);
}

function capBallSpeed(maxSpd) {
  let spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (spd > maxSpd) {
    ball.vx = (ball.vx / spd) * maxSpd;
    ball.vy = (ball.vy / spd) * maxSpd;
  }
}

function doSet(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 1.5;
  ball.vy = -9;
  ball.lastHitBy = rect === player ? 'player' : 'opponent';
  playSound('set');
  return true;
}

function doBump(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 6;
  ball.vy = -7;
  ball.lastHitBy = rect === player ? 'player' : 'opponent';
  capBallSpeed(11);
  playSound('bump');
  return true;
}

function doSpike(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  // Calculate spike angle based on ball position relative to net
  let distToNet = Math.abs(ball.x - NET_X);
  let spikeVx = direction * (8 + Math.min(distToNet / 50, 3));
  let spikeVy = 2 + (ball.y < NET_TOP ? 3 : 1);
  
  ball.vx = spikeVx;
  ball.vy = spikeVy;
  ball.lastHitBy = rect === player ? 'player' : 'opponent';
  capBallSpeed(13);
  playSound('spike');
  return true;
}

function rectCircleCollision(rx, ry, rw, rh, cx, cy, cr) {
  let closestX = clamp(cx, rx, rx + rw);
  let closestY = clamp(cy, ry, ry + rh);
  let dx = cx - closestX, dy = cy - closestY;
  return (dx * dx + dy * dy) < (cr * cr);
}

function pushBallOutOfRect(rect) {
  let closestX = clamp(ball.x, rect.x, rect.x + rect.w);
  let closestY = clamp(ball.y, rect.y, rect.y + rect.h);
  let dx = ball.x - closestX, dy = ball.y - closestY;
  let d = Math.sqrt(dx * dx + dy * dy);
  if (d === 0) { dx = 0; dy = -1; d = 1; }
  let overlap = ball.r - d;
  if (overlap > 0) {
    ball.x += (dx / d) * (overlap + 1);
    ball.y += (dy / d) * (overlap + 1);
  }
}

// ==================== PLAYER ====================
function updatePlayer() {
  player.vx = 0;
  if (keys['a']) { player.vx = -player.speed; player.facingRight = false; }
  if (keys['d']) { player.vx = player.speed; player.facingRight = true; }
  if ((keys['w'] || keys[' ']) && player.onGround) {
    player.vy = player.jumpPower;
    player.onGround = false;
  }

  if (keys['q']) {
    keys['q'] = false;
    doSet(player, 1);
  }

  if (clickedThisFrame) {
    if (!player.onGround && ball.y < player.y + 20) {
      doSpike(player, 1);
    } else {
      doBump(player, 1);
    }
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  if (player.y + player.h >= GROUND_Y) {
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
  }
  player.x = clamp(player.x, 0, NET_X - player.w - 5);
}

// ==================== OPPONENT (Remote or AI) ====================
function updateOpponent() {
  if (gameMode === 'host') {
    // Use remote input
    opponent.vx = 0;
    if (remoteInput.left) opponent.vx = opponent.speed;
    if (remoteInput.right) opponent.vx = -opponent.speed;
    if (remoteInput.jump && opponent.onGround) {
      opponent.vy = opponent.jumpPower;
      opponent.onGround = false;
    }
    if (remoteInput.set) {
      remoteInput.set = false;
      doSet(opponent, -1);
    }
    if (remoteInput.click) {
      remoteInput.click = false;
      if (!opponent.onGround && ball.y < opponent.y + 20) {
        doSpike(opponent, -1);
      } else {
        doBump(opponent, -1);
      }
    }
  } else if (gameMode === 'solo') {
    updateAI();
  }
  // Client doesn't update opponent locally (receives from host)

  if (gameMode !== 'client') {
    opponent.vy += GRAVITY;
    opponent.x += opponent.vx;
    opponent.y += opponent.vy;

    if (opponent.y + opponent.h >= GROUND_Y) {
      opponent.y = GROUND_Y - opponent.h;
      opponent.vy = 0;
      opponent.onGround = true;
    }
    opponent.x = clamp(opponent.x, NET_X + 5, W - opponent.w);
  }
}

function updateAI() {
  opponent.actionCooldown = Math.max(0, opponent.actionCooldown - 1);
  opponent.lastDecision++;

  let ballOnMySide = ball.x > NET_X;
  let distToB = ballCenter(opponent);

  // Predict where ball will land
  let predictX = ball.x;
  let predictY = ball.y;
  let pvx = ball.vx;
  let pvy = ball.vy;
  for (let i = 0; i < 80; i++) {
    pvy += BALL_GRAVITY;
    predictX += pvx;
    predictY += pvy;
    if (predictY >= GROUND_Y - 20) break;
  }

  // Add some randomness to decision making
  if (opponent.lastDecision > 30 + Math.random() * 20) {
    opponent.lastDecision = 0;
    
    // Occasionally make mistakes
    if (Math.random() < opponent.mistakeChance) {
      opponent.targetX = opponent.x + (Math.random() - 0.5) * 100;
    } else if (ballOnMySide) {
      // Different strategies based on personality
      if (opponent.personality < 0.3) {
        // Aggressive - try to get under ball quickly
        opponent.targetX = ball.x - opponent.w / 2 + (Math.random() - 0.5) * 30;
      } else if (opponent.personality < 0.7) {
        // Balanced - predict landing
        opponent.targetX = predictX - opponent.w / 2 + (Math.random() - 0.5) * 20;
      } else {
        // Defensive - stay back more
        opponent.targetX = Math.max(predictX - opponent.w / 2, W * 0.65);
      }
    } else {
      // Return to ready position with some variation
      opponent.targetX = W * (0.7 + opponent.personality * 0.1) - opponent.w / 2;
    }
  }

  opponent.targetX = clamp(opponent.targetX, NET_X + 10, W - opponent.w - 10);

  // Movement with slight delay/smoothing
  let diff = opponent.targetX - opponent.x;
  let moveThreshold = 8 + Math.random() * 5;
  
  if (Math.abs(diff) > moveThreshold) {
    let speedMod = 0.85 + Math.random() * 0.3;
    opponent.vx = (diff > 0 ? opponent.speed : -opponent.speed) * speedMod;
  } else {
    opponent.vx = 0;
  }

  // Action logic
  if (ballOnMySide && opponent.actionCooldown <= 0) {
    let ballComingDown = ball.vy > 0;
    let ballNear = distToB < HIT_RANGE + 20;
    let ballAbove = ball.y < opponent.y;
    let ballHigh = ball.y < NET_TOP - 20;

    // Jump decision
    if (ballAbove && ballComingDown && distToB < 160 && opponent.onGround) {
      let shouldJump = ball.y < NET_TOP + 80;
      // Add timing variation
      if (shouldJump && Math.random() > 0.15) {
        let jumpDelay = Math.floor(Math.random() * 8);
        setTimeout(() => {
          if (opponent.onGround) {
            opponent.vy = opponent.jumpPower * (0.9 + Math.random() * 0.2);
            opponent.onGround = false;
          }
        }, jumpDelay * 16);
      }
    }

    // Hit decisions
    if (ballNear && (ballAbove || ball.y < opponent.y + 30)) {
      let actionDelay = Math.floor(Math.random() * 5);
      
      setTimeout(() => {
        if (opponent.actionCooldown > 0) return;
        
        // Spike opportunity
        if (!opponent.onGround && ballHigh && ball.y < opponent.y + 40) {
          if (Math.random() > 0.2) {
            if (doSpike(opponent, -1)) {
              opponent.actionCooldown = 20 + Math.floor(Math.random() * 10);
              opponent.hitCount = 0;
            }
          }
        }
        // First touch - set up
        else if (opponent.hitCount === 0 && ballComingDown) {
          if (Math.random() > 0.3) {
            if (doSet(opponent, -1)) {
              opponent.actionCooldown = 12 + Math.floor(Math.random() * 8);
              opponent.hitCount = 1;
            }
          }
        }
        // Second touch - send over
        else if (opponent.hitCount >= 1) {
          if (doBump(opponent, -1)) {
            opponent.actionCooldown = 18 + Math.floor(Math.random() * 12);
            opponent.hitCount = 0;
          }
        }
      }, actionDelay * 16);
    }

    // Emergency hit - ball getting low
    if (ballNear && ball.y > NET_TOP + 40 && ballComingDown && opponent.actionCooldown <= 0) {
      if (doBump(opponent, -1)) {
        opponent.actionCooldown = 20 + Math.floor(Math.random() * 10);
        opponent.hitCount = 0;
      }
    }
  }

  // Reset hit count when ball goes to other side
  if (!ballOnMySide) {
    opponent.hitCount = 0;
  }
}

// ==================== BALL ====================
function updateBall() {
  if (gameMode === 'client') return; // Client receives ball state from host

  ball.vy += BALL_GRAVITY;
  ball.x += ball.vx;
  ball.y += ball.vy;

  capBallSpeed(13);

  // Walls
  if (ball.x - ball.r < 0) {
    ball.x = ball.r;
    ball.vx = Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.x + ball.r > W) {
    ball.x = W - ball.r;
    ball.vx = -Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.y - ball.r < 0) {
    ball.y = ball.r;
    ball.vy = Math.abs(ball.vy) * 0.7;
    playSound('bounce');
  }

  // Net collision
  let hitNet = false;
  if (ball.y + ball.r > NET_TOP && ball.y - ball.r < GROUND_Y) {
    if (ball.x - ball.r < NET_X + 4 && ball.x + ball.r > NET_X - 4) {
      hitNet = true;
      if (ball.x < NET_X) {
        ball.x = NET_X - 4 - ball.r;
        ball.vx = -Math.abs(ball.vx) * 0.6;
      } else {
        ball.x = NET_X + 4 + ball.r;
        ball.vx = Math.abs(ball.vx) * 0.6;
      }
    }
  }
  if (ball.x > NET_X - 10 && ball.x < NET_X + 10 && ball.y + ball.r > NET_TOP && ball.y < NET_TOP + 6) {
    ball.y = NET_TOP - ball.r;
    ball.vy = -Math.abs(ball.vy) * 0.5;
    hitNet = true;
  }
  if (hitNet) playSound('net');

  // Collision with players
  if (rectCircleCollision(player.x, player.y, player.w, player.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(player);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }
  if (rectCircleCollision(opponent.x, opponent.y, opponent.w, opponent.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(opponent);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }

  // Ball hits ground - SCORE
  if (ball.y + ball.r >= GROUND_Y && gameState === 'playing') {
    gameState = 'roundOver';
    roundTimer = 90;

    if (ball.x < NET_X) {
      opponentScore++;
      serveSide = 'player';
      playSound('lose');
    } else {
      playerScore++;
      serveSide = 'opponent';
      playSound('score');
    }
    document.getElementById('score').textContent = playerScore + ' - ' + opponentScore;
    ball.vy = 0;
    ball.vx = 0;
    ball.y = GROUND_Y - ball.r;
  }
}

// ==================== DRAWING ====================
function drawGame() {
  // Sky
  let grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, '#87CEEB');
  grad.addColorStop(1, '#d4eef7');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Ground
  ctx.fillStyle = '#5a8f3c';
  ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);

  // Court line
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 6]);
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(W, GROUND_Y);
  ctx.stroke();
  ctx.setLineDash([]);

  // Net
  ctx.fillStyle = '#333';
  ctx.fillRect(NET_X - 3, NET_TOP, 6, NET_HEIGHT);
  ctx.fillStyle = '#fff';
  ctx.fillRect(NET_X - 6, NET_TOP - 4, 12, 8);
  
  // Net lines
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  for (let ny = NET_TOP + 15; ny < GROUND_Y; ny += 15) {
    ctx.beginPath();
    ctx.moveTo(NET_X - 3, ny);
    ctx.lineTo(NET_X + 3, ny);
    ctx.stroke();
  }

  // Hit range indicator
  let pDist = ballCenter(player);
  if (pDist < HIT_RANGE + 30 && gameState === 'playing') {
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, HIT_RANGE, 0, Math.PI * 2);
    ctx.strokeStyle = pDist < HIT_RANGE ? 'rgba(255,255,100,0.4)' : 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Player shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(player.x + 5, GROUND_Y - 3, player.w - 10, 6);

  // Player (cube)
  ctx.fillStyle = player.color;
  ctx.fillRect(player.x, player.y, player.w, player.h);
  ctx.fillStyle = '#fff';
  ctx.fillRect(player.x + 30, player.y + 12, 12, 12);
  ctx.fillStyle = '#000';
  ctx.fillRect(player.x + 36, player.y + 16, 4, 4);

  // Opponent shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.fillRect(opponent.x + 5, GROUND_Y - 3, opponent.w - 10, 6);

  // Opponent (cube)
  ctx.fillStyle = opponent.color;
  ctx.fillRect(opponent.x, opponent.y, opponent.w, opponent.h);
  ctx.fillStyle = '#fff';
  ctx.fillRect(opponent.x + 8, opponent.y + 12, 12, 12);
  ctx.fillStyle = '#000';
  ctx.fillRect(opponent.x + 10, opponent.y + 16, 4, 4);

  // Ball shadow
  ctx.fillStyle = 'rgba(0,0,0,0.15)';
  ctx.beginPath();
  ctx.ellipse(ball.x, GROUND_Y, ball.r * 0.8, 4, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ball
  ctx.beginPath();
  ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
  ctx.fillStyle = ball.color;
  ctx.fill();
  ctx.strokeStyle = '#999';
  ctx.lineWidth = 1.5;
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(ball.x - 7, ball.y);
  ctx.quadraticCurveTo(ball.x, ball.y + 7, ball.x + 7, ball.y);
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  ctx.stroke();

  // Labels
  ctx.font = '13px monospace';
  ctx.fillStyle = '#fff';
  ctx.fillText('YOU', player.x + 8, player.y - 8);
  ctx.fillStyle = '#fcc';
  let oppLabel = gameMode === 'solo' ? 'AI' : 'P2';
  ctx.fillText(oppLabel, opponent.x + 14, opponent.y - 8);

  // Round over message
  if (gameState === 'roundOver') {
    ctx.textAlign = 'center';
    ctx.font = 'bold 28px monospace';

    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(W / 2 - 160, H / 2 - 70, 320, 65);

    if (ball.x < NET_X) {
      ctx.fillStyle = '#ff6666';
      ctx.fillText(gameMode === 'solo' ? 'AI Scores!' : 'P2 Scores!', W / 2, H / 2 - 38);
    } else {
      ctx.fillStyle = '#66ff66';
      ctx.fillText('You Score!', W / 2, H / 2 - 38);
    }
    ctx.font = '13px monospace';
    ctx.fillStyle = '#ddd';
    ctx.fillText('next round starting...', W / 2, H / 2 - 16);
    ctx.textAlign = 'left';
  }

  // Action hints
  if (gameState === 'playing' && pDist < HIT_RANGE) {
    ctx.textAlign = 'center';
    ctx.font = '12px monospace';
    ctx.fillStyle = 'rgba(255,255,200,0.9)';
    if (!player.onGround) {
      ctx.fillText('CLICK to SPIKE!', W / 2, H - 8);
    } else {
      ctx.fillText('Q = Set  |  CLICK = Bump', W / 2, H - 8);
    }
    ctx.textAlign = 'left';
  }
}

// ==================== GAME LOOP ====================
let lastTime = 0;
const TICK_RATE = 1000 / 60;

function gameLoop(timestamp) {
  if (timestamp - lastTime >= TICK_RATE) {
    lastTime = timestamp;

    if (gameState === 'playing' || gameState === 'roundOver') {
      updatePlayer();
      updateOpponent();
      updateBall();
      drawGame();

      // Send state/input for multiplayer
      if (gameMode === 'host') {
        sendState();
      } else if (gameMode === 'client') {
        sendInput();
      }

      if (gameState === 'roundOver') {
        roundTimer--;
        if (roundTimer <= 0) {
          playSound('whistle');
          resetRound();
        }
      }
    }

    clickedThisFrame = false;
  }

  requestAnimationFrame(gameLoop);
}

document.getElementById('score').textContent = '0 - 0';
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
