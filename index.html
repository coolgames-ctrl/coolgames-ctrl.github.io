<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cool Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;800;900&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: linear-gradient(180deg, #e8f4fc 0%, #c5dff8 50%, #a8d4f0 100%);
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    height: 100vh; 
    font-family: 'Nunito', sans-serif;
    user-select: none;
    overflow: hidden;
}

#menuScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
}

.menu-panel {
    background: linear-gradient(180deg, #ffffff 0%, #f0f5fa 100%);
    padding: 60px 100px;
    border-radius: 40px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.1), inset 0 2px 0 rgba(255,255,255,1);
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    overflow: hidden;
}

.menu-panel::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50%;
    background: linear-gradient(180deg, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 100%);
    border-radius: 40px 40px 0 0;
    pointer-events: none;
}

#menuTitle {
    font-size: 64px;
    font-weight: 900;
    background: linear-gradient(180deg, #5ab4e8 0%, #3a8fc9 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    margin-bottom: 50px;
    letter-spacing: -1px;
    position: relative;
    z-index: 1;
}

#startButton {
    width: 240px;
    height: 85px;
    background: linear-gradient(180deg, #ffffff 0%, #e8e8e8 100%);
    border: none;
    border-radius: 42px;
    font-family: 'Nunito', sans-serif;
    font-size: 26px;
    font-weight: 800;
    color: #5a5a5a;
    cursor: pointer;
    box-shadow: 0 8px 0 #c8c8c8, 0 12px 30px rgba(0,0,0,0.12);
    transition: all 0.15s ease;
    position: relative;
    overflow: hidden;
    z-index: 1;
}

#startButton::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 45%;
    background: linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%);
    border-radius: 42px 42px 50% 50%;
    pointer-events: none;
}

#startButton:hover {
    background: linear-gradient(180deg, #7dd3fc 0%, #38bdf8 100%);
    color: #fff;
    box-shadow: 0 8px 0 #0ea5e9, 0 12px 30px rgba(0,0,0,0.18);
    transform: scale(1.02);
}

#startButton:active {
    transform: translateY(6px) scale(1);
    box-shadow: 0 2px 0 #0ea5e9, 0 4px 15px rgba(0,0,0,0.12);
}

#gameContainer {
    display: none;
    flex-direction: column;
    align-items: center;
}

#score { 
    color: #4a4a4a;
    font-size: 36px;
    font-weight: 800;
    margin-bottom: 15px;
    background: linear-gradient(180deg, #ffffff 0%, #f0f5fa 100%);
    padding: 12px 40px;
    border-radius: 30px;
    box-shadow: 0 6px 20px rgba(0,0,0,0.1), inset 0 2px 0 rgba(255,255,255,1);
    letter-spacing: 8px;
}

canvas { 
    border-radius: 25px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.15);
    cursor: crosshair;
}

#info { 
    color: #5a5a5a;
    margin-top: 15px;
    font-size: 14px;
    font-weight: 600;
    text-align: center;
    line-height: 1.8;
    background: linear-gradient(180deg, #ffffff 0%, #f0f5fa 100%);
    padding: 12px 25px;
    border-radius: 20px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
}

/* Floating bubbles decoration */
.bubble {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.2) 100%);
    animation: floatBubble 8s ease-in-out infinite;
}

@keyframes floatBubble {
    0%, 100% { transform: translateY(0) translateX(0); }
    25% { transform: translateY(-15px) translateX(10px); }
    50% { transform: translateY(-25px) translateX(-5px); }
    75% { transform: translateY(-10px) translateX(15px); }
}
</style>
</head>
<body>

<!-- Decorative bubbles -->
<div class="bubble" style="width: 80px; height: 80px; top: 10%; left: 5%; animation-delay: 0s;"></div>
<div class="bubble" style="width: 50px; height: 50px; top: 20%; right: 10%; animation-delay: 1s;"></div>
<div class="bubble" style="width: 100px; height: 100px; bottom: 15%; left: 8%; animation-delay: 2s;"></div>
<div class="bubble" style="width: 60px; height: 60px; bottom: 25%; right: 5%; animation-delay: 3s;"></div>
<div class="bubble" style="width: 40px; height: 40px; top: 40%; left: 3%; animation-delay: 4s;"></div>

<div id="menuScreen">
    <div class="menu-panel">
        <div id="menuTitle">Cool Games</div>
        <button id="startButton">â–¶ Start</button>
    </div>
</div>

<div id="gameContainer">
    <div id="score">0 - 0</div>
    <canvas id="game" width="800" height="450"></canvas>
    <div id="info">A / D = move | W / SPACE = jump | Q = set | CLICK = bump | JUMP + CLICK = spike</div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const GROUND_Y = H - 50;
const NET_X = W / 2;
const NET_HEIGHT = 130;
const NET_TOP = GROUND_Y - NET_HEIGHT;
const GRAVITY = 0.32;
const BALL_GRAVITY = 0.20;
const HIT_RANGE = 80;

let playerScore = 0;
let aiScore = 0;
let serveSide = 'player';
let gameState = 'menu';
let roundTimer = 0;

const keys = {};
let clickedThisFrame = false;

// ==================== WII SOUND EFFECTS ====================
let audioCtx = null;
function initAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
}

function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;

  switch(type) {
    case 'menuClick':
      // Wii button click sound
      osc.type = 'sine';
      osc.frequency.setValueAtTime(1200, now);
      osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
      gain.gain.setValueAtTime(0.12, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
      osc.start(now);
      osc.stop(now + 0.12);
      // Second tone
      const osc1b = audioCtx.createOscillator();
      const gain1b = audioCtx.createGain();
      osc1b.connect(gain1b);
      gain1b.connect(audioCtx.destination);
      osc1b.type = 'sine';
      osc1b.frequency.setValueAtTime(1600, now + 0.02);
      gain1b.gain.setValueAtTime(0.08, now + 0.02);
      gain1b.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc1b.start(now + 0.02);
      osc1b.stop(now + 0.15);
      break;
    case 'menuHover':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(600, now);
      gain.gain.setValueAtTime(0.05, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
      osc.start(now);
      osc.stop(now + 0.06);
      break;
    case 'set':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(800, now);
      osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
      gain.gain.setValueAtTime(0.12, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
      osc.start(now);
      osc.stop(now + 0.15);
      break;
    case 'bump':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(700, now + 0.08);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
      osc.start(now);
      osc.stop(now + 0.18);
      break;
    case 'spike':
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, now);
      osc.frequency.exponentialRampToValueAtTime(900, now + 0.06);
      gain.gain.setValueAtTime(0.2, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
      osc.start(now);
      osc.stop(now + 0.2);
      break;
    case 'score':
      // Wii celebration sound
      const notes = [523, 659, 784, 1047];
      notes.forEach((freq, i) => {
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.connect(g);
        g.connect(audioCtx.destination);
        o.type = 'sine';
        o.frequency.setValueAtTime(freq, now + i * 0.1);
        g.gain.setValueAtTime(0.12, now + i * 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, now + i * 0.1 + 0.2);
        o.start(now + i * 0.1);
        o.stop(now + i * 0.1 + 0.2);
      });
      return;
    case 'lose':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(400, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.4);
      gain.gain.setValueAtTime(0.15, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
      osc.start(now);
      osc.stop(now + 0.5);
      break;
    case 'net':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(250, now);
      gain.gain.setValueAtTime(0.08, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
      osc.start(now);
      osc.stop(now + 0.1);
      break;
    case 'bounce':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(350, now);
      osc.frequency.exponentialRampToValueAtTime(200, now + 0.06);
      gain.gain.setValueAtTime(0.06, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
      osc.start(now);
      osc.stop(now + 0.08);
      break;
    case 'whistle':
      osc.type = 'sine';
      osc.frequency.setValueAtTime(900, now);
      osc.frequency.setValueAtTime(1100, now + 0.1);
      osc.frequency.setValueAtTime(900, now + 0.2);
      gain.gain.setValueAtTime(0.1, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
      osc.start(now);
      osc.stop(now + 0.35);
      break;
  }
}

// ==================== INPUT ====================
document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  e.preventDefault();
});
document.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });
canvas.addEventListener('mousedown', e => {
  initAudio();
  clickedThisFrame = true;
});

// Menu button handlers
const startButton = document.getElementById('startButton');
startButton.addEventListener('mouseenter', () => {
  initAudio();
  playSound('menuHover');
});
startButton.addEventListener('click', () => {
  initAudio();
  playSound('menuClick');
  setTimeout(() => {
    document.getElementById('menuScreen').style.display = 'none';
    document.getElementById('gameContainer').style.display = 'flex';
    gameState = 'playing';
    playSound('whistle');
    resetRound();
  }, 200);
});

// ==================== ENTITIES ====================
const player = {
  x: 150, y: GROUND_Y - 60, w: 50, h: 60,
  vx: 0, vy: 0, speed: 3.2, jumpPower: -7.5,
  onGround: true, color: '#3b82f6', facingRight: true
};

const ai = {
  x: W - 200, y: GROUND_Y - 60, w: 50, h: 60,
  vx: 0, vy: 0, speed: 3.0, jumpPower: -7.5,
  onGround: true, color: '#ef4444',
  actionCooldown: 0, hitCount: 0, phase: 'idle'
};

const ball = {
  x: 200, y: 150, r: 16,
  vx: 0, vy: 0, color: '#fff',
  lastHitBy: null, rotation: 0
};

// ==================== GAME LOGIC ====================
function startGame() {
  gameState = 'playing';
  playerScore = 0;
  aiScore = 0;
  serveSide = 'player';
  resetRound();
}

function resetRound() {
  player.x = 150; player.y = GROUND_Y - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
  ai.x = W - 200; ai.y = GROUND_Y - ai.h; ai.vx = 0; ai.vy = 0; ai.onGround = true;
  ai.actionCooldown = 0;
  ai.hitCount = 0;
  ai.phase = 'idle';

  ball.vy = 0;
  ball.vx = 0;
  ball.lastHitBy = null;
  ball.rotation = 0;
  if (serveSide === 'player') {
    ball.x = 200; ball.y = 130;
  } else {
    ball.x = W - 200; ball.y = 130;
  }
  gameState = 'playing';
  roundTimer = 0;
  document.getElementById('score').textContent = playerScore + ' - ' + aiScore;
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

function dist(x1, y1, x2, y2) {
  let dx = x1 - x2, dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}

function ballCenter(rect) {
  return dist(rect.x + rect.w / 2, rect.y + rect.h / 2, ball.x, ball.y);
}

function capBallSpeed(maxSpd) {
  let spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  if (spd > maxSpd) {
    ball.vx = (ball.vx / spd) * maxSpd;
    ball.vy = (ball.vy / spd) * maxSpd;
  }
}

function doSet(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = 0;
  ball.vy = -8.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  playSound('set');
  return true;
}

function doBump(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 7;
  ball.vy = -7.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  capBallSpeed(11);
  playSound('bump');
  return true;
}

function doSpike(rect, direction) {
  if (ballCenter(rect) > HIT_RANGE) return false;
  ball.vx = direction * 7;
  ball.vy = 3.5;
  ball.lastHitBy = rect === player ? 'player' : 'ai';
  capBallSpeed(11);
  playSound('spike');
  return true;
}

function rectCircleCollision(rx, ry, rw, rh, cx, cy, cr) {
  let closestX = clamp(cx, rx, rx + rw);
  let closestY = clamp(cy, ry, ry + rh);
  let dx = cx - closestX, dy = cy - closestY;
  return (dx * dx + dy * dy) < (cr * cr);
}

function pushBallOutOfRect(rect) {
  let closestX = clamp(ball.x, rect.x, rect.x + rect.w);
  let closestY = clamp(ball.y, rect.y, rect.y + rect.h);
  let dx = ball.x - closestX, dy = ball.y - closestY;
  let d = Math.sqrt(dx * dx + dy * dy);
  if (d === 0) { dx = 0; dy = -1; d = 1; }
  let overlap = ball.r - d;
  if (overlap > 0) {
    ball.x += (dx / d) * (overlap + 1);
    ball.y += (dy / d) * (overlap + 1);
  }
}

// ==================== PLAYER ====================
function updatePlayer() {
  player.vx = 0;
  if (keys['a']) { player.vx = -player.speed; player.facingRight = false; }
  if (keys['d']) { player.vx = player.speed; player.facingRight = true; }
  if ((keys['w'] || keys[' ']) && player.onGround) {
    player.vy = player.jumpPower;
    player.onGround = false;
  }

  if (keys['q']) {
    keys['q'] = false;
    doSet(player, 1);
  }

  if (clickedThisFrame) {
    if (!player.onGround) {
      doSpike(player, 1);
    } else {
      doBump(player, 1);
    }
  }

  player.vy += GRAVITY;
  player.x += player.vx;
  player.y += player.vy;

  if (player.y + player.h >= GROUND_Y) {
    player.y = GROUND_Y - player.h;
    player.vy = 0;
    player.onGround = true;
  }
  player.x = clamp(player.x, 0, NET_X - player.w - 5);
}

// ==================== AI ====================
function updateAI() {
  ai.actionCooldown = Math.max(0, ai.actionCooldown - 1);

  let ballOnMySide = ball.x > NET_X;
  let distToB = ballCenter(ai);

  let predictX = ball.x;
  let predictY = ball.y;
  let pvx = ball.vx;
  let pvy = ball.vy;
  for (let i = 0; i < 60; i++) {
    pvy += BALL_GRAVITY;
    predictX += pvx;
    predictY += pvy;
    if (predictY >= GROUND_Y) break;
  }

  let targetX;
  if (ballOnMySide) {
    if (ball.vy > 0 && ball.y > NET_TOP - 50) {
      targetX = ball.x - ai.w / 2;
    } else {
      targetX = predictX - ai.w / 2;
    }
  } else {
    targetX = W * 0.72 - ai.w / 2;
  }

  targetX = clamp(targetX, NET_X + 5, W - ai.w);

  let diff = targetX - ai.x;
  if (Math.abs(diff) > 5) {
    ai.vx = diff > 0 ? ai.speed : -ai.speed;
  } else {
    ai.vx = 0;
  }

  if (ballOnMySide && ai.actionCooldown <= 0) {
    let ballComingDown = ball.vy > 0;
    let ballNear = distToB < HIT_RANGE + 15;
    let ballAbove = ball.y < ai.y;

    if (ballAbove && ballComingDown && distToB < 140 && ai.onGround) {
      if (ball.y < NET_TOP + 60) {
        ai.vy = ai.jumpPower;
        ai.onGround = false;
      }
    }

    if (ballNear && ballAbove) {
      if (ai.hitCount === 0 && ballComingDown) {
        if (doSet(ai, -1)) {
          ai.actionCooldown = 15;
          ai.hitCount = 1;
        }
      } else if (ai.hitCount >= 1) {
        if (!ai.onGround && ball.y < NET_TOP + 40) {
          if (doSpike(ai, -1)) {
            ai.actionCooldown = 25;
            ai.hitCount = 0;
          }
        } else {
          if (doBump(ai, -1)) {
            ai.actionCooldown = 25;
            ai.hitCount = 0;
          }
        }
      }
    }

    if (ballNear && ballComingDown && ai.actionCooldown <= 0 && ball.y > NET_TOP) {
      if (doBump(ai, -1)) {
        ai.actionCooldown = 25;
        ai.hitCount = 0;
      }
    }
  }

  if (!ballOnMySide) {
    ai.hitCount = 0;
  }

  ai.vy += GRAVITY;
  ai.x += ai.vx;
  ai.y += ai.vy;

  if (ai.y + ai.h >= GROUND_Y) {
    ai.y = GROUND_Y - ai.h;
    ai.vy = 0;
    ai.onGround = true;
  }
  ai.x = clamp(ai.x, NET_X + 5, W - ai.w);
}

// ==================== BALL ====================
function updateBall() {
  ball.vy += BALL_GRAVITY;
  ball.x += ball.vx;
  ball.y += ball.vy;
  ball.rotation += ball.vx * 0.05;

  capBallSpeed(11);

  if (ball.x - ball.r < 0) {
    ball.x = ball.r;
    ball.vx = Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.x + ball.r > W) {
    ball.x = W - ball.r;
    ball.vx = -Math.abs(ball.vx) * 0.7;
    playSound('bounce');
  }
  if (ball.y - ball.r < 0) {
    ball.y = ball.r;
    ball.vy = Math.abs(ball.vy) * 0.7;
    playSound('bounce');
  }

  let hitNet = false;
  if (ball.y + ball.r > NET_TOP && ball.y - ball.r < GROUND_Y) {
    if (ball.x - ball.r < NET_X + 4 && ball.x + ball.r > NET_X - 4) {
      hitNet = true;
      if (ball.x < NET_X) {
        ball.x = NET_X - 4 - ball.r;
        ball.vx = -Math.abs(ball.vx) * 0.6;
      } else {
        ball.x = NET_X + 4 + ball.r;
        ball.vx = Math.abs(ball.vx) * 0.6;
      }
    }
  }
  if (ball.x > NET_X - 10 && ball.x < NET_X + 10 && ball.y + ball.r > NET_TOP && ball.y < NET_TOP + 6) {
    ball.y = NET_TOP - ball.r;
    ball.vy = -Math.abs(ball.vy) * 0.5;
    hitNet = true;
  }
  if (hitNet) playSound('net');

  if (rectCircleCollision(player.x, player.y, player.w, player.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(player);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }
  if (rectCircleCollision(ai.x, ai.y, ai.w, ai.h, ball.x, ball.y, ball.r)) {
    pushBallOutOfRect(ai);
    ball.vy = Math.min(ball.vy, -2);
    playSound('bounce');
  }

  if (ball.y + ball.r >= GROUND_Y && gameState === 'playing') {
    gameState = 'roundOver';
    roundTimer = 90;

    if (ball.x < NET_X) {
      aiScore++;
      serveSide = 'player';
      playSound('lose');
    } else {
      playerScore++;
      serveSide = 'ai';
      playSound('score');
    }
    document.getElementById('score').textContent = playerScore + ' - ' + aiScore;
    ball.vy = 0;
    ball.vx = 0;
    ball.y = GROUND_Y - ball.r;
  }
}

// ==================== DRAWING ====================
function drawMii(x, y, w, h, color, facingLeft) {
  // Body (rounded rectangle)
  ctx.fillStyle = color;
  const bodyRadius = 12;
  ctx.beginPath();
  ctx.roundRect(x, y + h * 0.35, w, h * 0.65, bodyRadius);
  ctx.fill();
  
  // Body shine
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath();
  ctx.roundRect(x + 4, y + h * 0.35 + 4, w * 0.3, h * 0.4, 6);
  ctx.fill();

  // Head (circle)
  const headRadius = w * 0.45;
  const headX = x + w / 2;
  const headY = y + headRadius;
  
  // Head gradient
  const headGrad = ctx.createRadialGradient(headX - 5, headY - 5, 0, headX, headY, headRadius);
  headGrad.addColorStop(0, '#ffefd5');
  headGrad.addColorStop(1, '#f5d5b8');
  ctx.fillStyle = headGrad;
  ctx.beginPath();
  ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  const eyeOffsetX = facingLeft ? -6 : 6;
  const eyeY = headY - 2;
  
  // Eye whites
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(headX + eyeOffsetX - 6, eyeY, 6, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(headX + eyeOffsetX + 6, eyeY, 6, 7, 0, 0, Math.PI * 2);
  ctx.fill();

  // Pupils
  ctx.fillStyle = '#333';
  ctx.beginPath();
  ctx.arc(headX + eyeOffsetX - 5 + (facingLeft ? -1 : 1), eyeY + 1, 3, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(headX + eyeOffsetX + 7 + (facingLeft ? -1 : 1), eyeY + 1, 3, 0, Math.PI * 2);
  ctx.fill();

  // Eyebrows
  ctx.strokeStyle = '#654321';
  ctx.lineWidth = 2;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(headX + eyeOffsetX - 10, eyeY - 10);
  ctx.lineTo(headX + eyeOffsetX - 2, eyeY - 9);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(headX + eyeOffsetX + 2, eyeY - 9);
  ctx.lineTo(headX + eyeOffsetX + 10, eyeY - 10);
  ctx.stroke();

  // Smile
  ctx.strokeStyle = '#c96';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(headX + eyeOffsetX, eyeY + 12, 6, 0.1 * Math.PI, 0.9 * Math.PI);
  ctx.stroke();

  // Blush
  ctx.fillStyle = 'rgba(255, 150, 150, 0.3)';
  ctx.beginPath();
  ctx.ellipse(headX + eyeOffsetX - 14, eyeY + 8, 5, 3, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(headX + eyeOffsetX + 14, eyeY + 8, 5, 3, 0, 0, Math.PI * 2);
  ctx.fill();
}

function drawGame() {
  // Sky gradient (Wii style - cleaner, brighter)
  let skyGrad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
  skyGrad.addColorStop(0, '#87CEEB');
  skyGrad.addColorStop(0.5, '#b5e3f5');
  skyGrad.addColorStop(1, '#d4f1f9');
  ctx.fillStyle = skyGrad;
  ctx.fillRect(0, 0, W, GROUND_Y);

  // Sun
  ctx.fillStyle = '#fff5d4';
  ctx.beginPath();
  ctx.arc(680, 60, 40, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fffaed';
  ctx.beginPath();
  ctx.arc(680, 60, 32, 0, Math.PI * 2);
  ctx.fill();

  // Clouds (Wii style)
  function drawCloud(x, y, scale) {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.arc(x, y, 25 * scale, 0, Math.PI * 2);
    ctx.arc(x + 25 * scale, y - 10 * scale, 20 * scale, 0, Math.PI * 2);
    ctx.arc(x + 50 * scale, y, 25 * scale, 0, Math.PI * 2);
    ctx.arc(x + 25 * scale, y + 5 * scale, 18 * scale, 0, Math.PI * 2);
    ctx.fill();
  }
  drawCloud(100, 50, 1);
  drawCloud(550, 35, 0.8);
  drawCloud(300, 70, 0.6);

  // Ground (grass with Wii-style gradient)
  let groundGrad = ctx.createLinearGradient(0, GROUND_Y, 0, H);
  groundGrad.addColorStop(0, '#7bc96f');
  groundGrad.addColorStop(1, '#5a9f4e');
  ctx.fillStyle = groundGrad;
  ctx.beginPath();
  ctx.roundRect(0, GROUND_Y, W, H - GROUND_Y, [0, 0, 15, 15]);
  ctx.fill();

  // Ground line
  ctx.strokeStyle = 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, GROUND_Y);
  ctx.lineTo(W, GROUND_Y);
  ctx.stroke();

  // Net (Wii-style, cleaner)
  ctx.fillStyle = '#f5f5f5';
  ctx.beginPath();
  ctx.roundRect(NET_X - 5, NET_TOP, 10, NET_HEIGHT, 5);
  ctx.fill();
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Net top
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.roundRect(NET_X - 12, NET_TOP - 8, 24, 16, 8);
  ctx.fill();
  ctx.shadowColor = 'transparent';

  // Net pattern
  ctx.strokeStyle = 'rgba(200,200,200,0.5)';
  ctx.lineWidth = 1;
  for (let ny = NET_TOP + 20; ny < GROUND_Y; ny += 20) {
    ctx.beginPath();
    ctx.moveTo(NET_X - 5, ny);
    ctx.lineTo(NET_X + 5, ny);
    ctx.stroke();
  }

  // Hit range indicator
  let pDist = ballCenter(player);
  if (pDist < HIT_RANGE + 30 && gameState === 'playing') {
    ctx.beginPath();
    ctx.arc(player.x + player.w / 2, player.y + player.h / 2, HIT_RANGE, 0, Math.PI * 2);
    let alpha = pDist < HIT_RANGE ? 0.4 : 0.15;
    ctx.strokeStyle = `rgba(100,200,255,${alpha})`;
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 8]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  // Player shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.beginPath();
  ctx.ellipse(player.x + player.w / 2, GROUND_Y + 2, player.w * 0.4, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // Player (Mii-style)
  drawMii(player.x, player.y, player.w, player.h, player.color, false);

  // AI shadow
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  ctx.beginPath();
  ctx.ellipse(ai.x + ai.w / 2, GROUND_Y + 2, ai.w * 0.4, 6, 0, 0, Math.PI * 2);
  ctx.fill();

  // AI (Mii-style)
  drawMii(ai.x, ai.y, ai.w, ai.h, ai.color, true);

  // Ball shadow
  ctx.fillStyle = 'rgba(0,0,0,0.12)';
  ctx.beginPath();
  ctx.ellipse(ball.x, GROUND_Y + 2, ball.r * 0.7, 5, 0, 0, Math.PI * 2);
  ctx.fill();

  // Ball (Wii-style volleyball)
  ctx.save();
  ctx.translate(ball.x, ball.y);
  ctx.rotate(ball.rotation);
  
  // Ball gradient
  let ballGrad = ctx.createRadialGradient(-4, -4, 0, 0, 0, ball.r);
  ballGrad.addColorStop(0, '#ffffff');
  ballGrad.addColorStop(0.7, '#f0f0f0');
  ballGrad.addColorStop(1, '#d8d8d8');
  ctx.fillStyle = ballGrad;
  ctx.beginPath();
  ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
  ctx.fill();
  
  // Ball outline
  ctx.strokeStyle = '#bbb';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Ball pattern
  ctx.strokeStyle = '#ccc';
  ctx.lineWidth = 1.5;
  ctx.beginPath();
  ctx.arc(0, 0, ball.r * 0.6, 0, Math.PI * 2);
  ctx.stroke();
  
  // Ball lines
  ctx.beginPath();
  ctx.moveTo(-ball.r, 0);
  ctx.lineTo(ball.r, 0);
  ctx.moveTo(0, -ball.r);
  ctx.lineTo(0, ball.r);
  ctx.stroke();
  
  ctx.restore();

  // Labels (Wii-style rounded boxes)
  ctx.font = 'bold 12px Nunito, sans-serif';
  
  // Player label
  ctx.fillStyle = 'rgba(59, 130, 246, 0.9)';
  ctx.beginPath();
  ctx.roundRect(player.x + player.w/2 - 22, player.y - 24, 44, 18, 9);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText('YOU', player.x + player.w / 2, player.y - 11);
  
  // AI label
  ctx.fillStyle = 'rgba(239, 68, 68, 0.9)';
  ctx.beginPath();
  ctx.roundRect(ai.x + ai.w/2 - 16, ai.y - 24, 32, 18, 9);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.fillText('CPU', ai.x + ai.w / 2, ai.y - 11);
  ctx.textAlign = 'left';

  // Round over message
  if (gameState === 'roundOver') {
    ctx.textAlign = 'center';
    
    // Message box
    ctx.fillStyle = 'rgba(255,255,255,0.95)';
    ctx.beginPath();
    ctx.roundRect(W / 2 - 140, H / 2 - 60, 280, 80, 20);
    ctx.fill();
    ctx.strokeStyle = ball.x < NET_X ? '#ef4444' : '#22c55e';
    ctx.lineWidth = 4;
    ctx.stroke();

    ctx.font = 'bold 26px Nunito, sans-serif';
    if (ball.x < NET_X) {
      ctx.fillStyle = '#ef4444';
      ctx.fillText('CPU Scores!', W / 2, H / 2 - 22);
    } else {
      ctx.fillStyle = '#22c55e';
      ctx.fillText('You Score!', W / 2, H / 2 - 22);
    }
    ctx.font = '14px Nunito, sans-serif';
    ctx.fillStyle = '#666';
    ctx.fillText('Next round starting...', W / 2, H / 2 + 6);
    ctx.textAlign = 'left';
  }

  // Action hints (Wii-style)
  if (gameState === 'playing' && pDist < HIT_RANGE) {
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.beginPath();
    ctx.roundRect(W/2 - 100, H - 32, 200, 24, 12);
    ctx.fill();
    
    ctx.font = 'bold 12px Nunito, sans-serif';
    ctx.fillStyle = '#4a4a4a';
    if (!player.onGround) {
      ctx.fillText('ðŸ CLICK to SPIKE!', W / 2, H - 15);
    } else {
      ctx.fillText('Q = Set  |  CLICK = Bump', W / 2, H - 15);
    }
    ctx.textAlign = 'left';
  }
}

// ==================== GAME LOOP ====================
function gameLoop() {
  if (gameState === 'menu') {
    // Menu is handled by HTML/CSS
  } else if (gameState === 'roundOver') {
    updatePlayer();
    updateBall();
    drawGame();
    roundTimer--;
    if (roundTimer <= 0) {
      playSound('whistle');
      resetRound();
    }
  } else if (gameState === 'playing') {
    updatePlayer();
    updateAI();
    updateBall();
    drawGame();
  }

  clickedThisFrame = false;
  requestAnimationFrame(gameLoop);
}

// Polyfill for roundRect
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r, r, r, r];
    else if (typeof r === 'undefined') r = [0, 0, 0, 0];
    this.moveTo(x + r[0], y);
    this.lineTo(x + w - r[1], y);
    this.quadraticCurveTo(x + w, y, x + w, y + r[1]);
    this.lineTo(x + w, y + h - r[2]);
    this.quadraticCurveTo(x + w, y + h, x + w - r[2], y + h);
    this.lineTo(x + r[3], y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r[3]);
    this.lineTo(x, y + r[0]);
    this.quadraticCurveTo(x, y, x + r[0], y);
    this.closePath();
    return this;
  };
}

document.getElementById('score').textContent = '0 - 0';
gameLoop();
</script>
</body>
</html>
