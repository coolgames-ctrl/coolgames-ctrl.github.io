<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cool Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }
body { 
    background: #fafafa;
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    justify-content: center; 
    min-height: 100vh; 
    font-family: 'Courier Prime', monospace;
    user-select: none;
    overflow-x: hidden;
    padding: 10px;
}

.screen {
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: #fafafa;
}

#menuScreen { display: flex; }

#menuTitle {
    font-size: 52px;
    font-weight: 700;
    color: #222;
    margin-bottom: 60px;
    letter-spacing: -1px;
}

.menu-button {
    width: 220px;
    height: 50px;
    background: #222;
    border: none;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 16px;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 8px 0;
}

.menu-button:hover { background: #444; transform: scale(1.05); }
.menu-button:active { transform: scale(0.98); }
.menu-button:disabled { background: #999; cursor: not-allowed; transform: none; }
.menu-button.secondary { background: #fff; color: #222; border: 2px solid #222; }
.menu-button.secondary:hover { background: #222; color: #fff; }
.menu-button.small { width: 120px; height: 40px; font-size: 14px; }

#lobbyTitle, #waitingTitle, #settingsTitle {
    font-size: 28px;
    font-weight: 700;
    color: #222;
    margin-bottom: 30px;
}

#lobbyInput {
    width: 250px;
    height: 50px;
    border: 2px solid #222;
    border-radius: 12px;
    font-family: 'Courier Prime', monospace;
    font-size: 18px;
    padding: 0 15px;
    margin-bottom: 20px;
    text-align: center;
    text-transform: uppercase;
    background: #fff;
}

#lobbyInput:focus { outline: none; border-color: #3366ff; }
#lobbyStatus, #waitingStatus { color: #666; margin-top: 20px; font-size: 14px; }

#lobbyCode {
    font-size: 48px;
    font-weight: 700;
    color: #3366ff;
    margin-bottom: 20px;
    letter-spacing: 6px;
    background: #eef4ff;
    padding: 15px 30px;
    border-radius: 12px;
}

.back-button {
    position: absolute;
    top: 30px;
    left: 30px;
    background: none;
    border: 2px solid #222;
    border-radius: 8px;
    padding: 10px 20px;
    font-family: 'Courier Prime', monospace;
    font-size: 14px;
    font-weight: 700;
    cursor: pointer;
    transition: all 0.2s ease;
}

.back-button:hover { background: #222; color: #fff; }

.settings-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-height: 400px;
    overflow-y: auto;
    padding: 10px;
}

.radio-group { display: flex; flex-direction: column; gap: 10px; }

.radio-option {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 16px;
    background: #fff;
    border: 2px solid #ddd;
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    width: 320px;
}

.radio-option:hover { border-color: #999; }
.radio-option.selected { border-color: #4CAF50; background: #e8f5e9; }

.radio-circle {
    width: 20px;
    height: 20px;
    border: 2px solid #999;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
}

.radio-option.selected .radio-circle { border-color: #4CAF50; }
.radio-circle::after {
    content: '';
    width: 10px;
    height: 10px;
    background: #4CAF50;
    border-radius: 50%;
    display: none;
}
.radio-option.selected .radio-circle::after { display: block; }

.radio-text { flex: 1; }
.radio-title { font-weight: 700; font-size: 14px; }
.radio-desc { font-size: 11px; color: #666; margin-top: 2px; }

#gameContainer {
    display: none;
    flex-direction: column;
    align-items: center;
    position: relative;
}

#gameHeader {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    max-width: 1220px;
    margin-bottom: 10px;
}

#gameHeaderLeft { display: flex; align-items: center; gap: 15px; }
#score { color: #222; font-size: 32px; font-weight: 700; letter-spacing: 8px; }
#mode-indicator { font-size: 14px; color: #666; }

#touchIndicator {
    font-size: 14px;
    color: #666;
    background: #fff;
    padding: 6px 12px;
    border-radius: 8px;
    border: 1px solid #ddd;
}

.game-wrapper { display: flex; gap: 15px; }
canvas { border: 2px solid #222; cursor: crosshair; border-radius: 8px; }

#chatPanel {
    width: 220px;
    height: 520px;
    background: #fff;
    border: 2px solid #222;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

#chatHeader {
    background: #222;
    color: #fff;
    padding: 10px;
    font-size: 14px;
    font-weight: 700;
    text-align: center;
}

#chatMessages {
    flex: 1;
    overflow-y: auto;
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.chat-message { padding: 8px 10px; border-radius: 8px; font-size: 12px; word-wrap: break-word; }
.chat-message.you { background: #e3f2fd; align-self: flex-end; max-width: 85%; }
.chat-message.opponent { background: #ffebee; align-self: flex-start; max-width: 85%; }
.chat-message.system { background: #f5f5f5; align-self: center; color: #666; font-style: italic; text-align: center; }

#chatInputWrapper { display: flex; border-top: 2px solid #222; }
#chatInput { flex: 1; border: none; padding: 10px; font-family: 'Courier Prime', monospace; font-size: 12px; outline: none; }
#chatSend { background: #222; color: #fff; border: none; padding: 10px 15px; cursor: pointer; font-weight: 700; }
#chatSend:hover { background: #444; }

#info { color: #666; margin-top: 12px; font-size: 13px; text-align: center; line-height: 1.8; }

.loading-dots::after { content: ''; animation: dots 1.5s infinite; }
@keyframes dots {
    0%, 20% { content: ''; }
    40% { content: '.'; }
    60% { content: '..'; }
    80%, 100% { content: '...'; }
}

.error-text { color: #cc3333; }
.success-text { color: #33aa33; }

.mode-badge {
    display: inline-block;
    padding: 4px 10px;
    border-radius: 6px;
    font-size: 12px;
    font-weight: 700;
    margin-left: 10px;
}

.mode-badge.volleyball { background: #e3f2fd; color: #1976d2; }
.mode-badge.tennis { background: #c8e6c9; color: #388e3c; }
.mode-badge.badminton { background: #fff3e0; color: #e65100; }
.mode-badge.basketball { background: #ffccbc; color: #bf360c; }
</style>
<script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
</head>
<body>

<div id="menuScreen" class="screen">
    <div id="menuTitle">Cool Games</div>
    <button class="menu-button" id="createBtn">Create Lobby</button>
    <button class="menu-button" id="joinBtn">Join Lobby</button>
    <button class="menu-button" id="soloBtn">Play vs AI</button>
    <button class="menu-button secondary" id="settingsBtn">Settings</button>
</div>

<div id="settingsScreen" class="screen">
    <button class="back-button" id="settingsBackBtn">‚Üê Back</button>
    <div id="settingsTitle">Settings</div>
    <div class="settings-container">
        <div style="font-weight: 700; margin-bottom: 5px;">Game Mode:</div>
        <div class="radio-group" id="gameModeGroup">
            <div class="radio-option selected" data-mode="volleyball">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üèê Volleyball</div>
                    <div class="radio-desc">3 touches max, no bounces</div>
                </div>
            </div>
            <div class="radio-option" data-mode="tennis">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üéæ Tennis</div>
                    <div class="radio-desc">1 touch, 1 bounce allowed</div>
                </div>
            </div>
            <div class="radio-option" data-mode="badminton">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üè∏ Badminton</div>
                    <div class="radio-desc">1 touch, no bounces, shuttlecock</div>
                </div>
            </div>
            <div class="radio-option" data-mode="basketball">
                <div class="radio-circle"></div>
                <div class="radio-text">
                    <div class="radio-title">üèÄ Basketball</div>
                    <div class="radio-desc">Hold RIGHT CLICK to shoot, dunk near hoop</div>
                </div>
            </div>
        </div>
        <p style="margin-top: 15px; color: #666; font-size: 11px; text-align: center; max-width: 300px;">
            Both players must have the same mode selected to play together.
        </p>
    </div>
</div>

<div id="lobbyScreen" class="screen">
    <button class="back-button" id="lobbyBackBtn">‚Üê Back</button>
    <div id="lobbyTitle">Join Lobby</div>
    <input type="text" id="lobbyInput" placeholder="ENTER CODE" maxlength="8" autocomplete="off" spellcheck="false">
    <button class="menu-button" id="connectBtn">Connect</button>
    <div id="lobbyStatus"></div>
</div>

<div id="waitingScreen" class="screen">
    <button class="back-button" id="waitingBackBtn">‚Üê Back</button>
    <div id="waitingTitle">Your Lobby Code</div>
    <div id="lobbyCode">-----</div>
    <div id="waitingStatus">Waiting for opponent<span class="loading-dots"></span></div>
</div>

<div id="gameContainer">
    <div id="gameHeader">
        <div id="gameHeaderLeft">
            <button class="menu-button small secondary" id="exitGameBtn">‚Üê Menu</button>
            <div id="mode-indicator"></div>
        </div>
        <div id="score">0 - 0</div>
        <div id="touchIndicator"></div>
    </div>
    <div class="game-wrapper">
        <canvas id="game" width="980" height="520"></canvas>
        <div id="chatPanel">
            <div id="chatHeader">Chat</div>
            <div id="chatMessages"></div>
            <div id="chatInputWrapper">
                <input type="text" id="chatInput" placeholder="Type message..." maxlength="100">
                <button id="chatSend">‚Üí</button>
            </div>
        </div>
    </div>
    <div id="info"></div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

const GROUND_Y = H - 50;
const NET_X = W / 2;
const GRAVITY = 0.35;
const HIT_RANGE = 90;
const HAND_SIZE = 12;

let selectedMode = 'volleyball';
let activeMode = 'volleyball';

const MODES = {
    volleyball: {
        netHeight: 140, maxTouches: 3, allowBounce: false,
        ballGravity: 0.22, ballColor: '#ffffff',
        playerColor: '#3366ff', opponentColor: '#ff4444',
        handColor: '#2255dd', opponentHandColor: '#dd3333',
        groundColor: '#5a8f3c', skyColors: ['#87CEEB', '#d4eef7'],
        ballSize: 16, hasRacket: false
    },
    tennis: {
        netHeight: 80, maxTouches: 1, allowBounce: true,
        ballGravity: 0.25, ballColor: '#ccff00',
        playerColor: '#2e7d32', opponentColor: '#c62828',
        handColor: '#1b5e20', opponentHandColor: '#b71c1c',
        groundColor: '#1565c0', skyColors: ['#4fc3f7', '#81d4fa'],
        ballSize: 14, hasRacket: true, racketColor: '#8B4513'
    },
    badminton: {
        netHeight: 155, maxTouches: 1, allowBounce: false,
        ballGravity: 0.12, shuttleDrag: 0.992,
        ballColor: '#ffffff',
        playerColor: '#6a1b9a', opponentColor: '#00838f',
        handColor: '#4a148c', opponentHandColor: '#006064',
        groundColor: '#43a047', skyColors: ['#fff8e1', '#ffecb3'],
        ballSize: 12, hasRacket: true, racketColor: '#333'
    },
    basketball: {
        netHeight: 0, maxTouches: 999, allowBounce: true,
        ballGravity: 0.35, ballColor: '#ff6600',
        playerColor: '#1565c0', opponentColor: '#c62828',
        handColor: '#0d47a1', opponentHandColor: '#b71c1c',
        groundColor: '#d7a86e', skyColors: ['#424242', '#616161'],
        ballSize: 18, hasRacket: false,
        hoopHeight: 140, hoopWidth: 50
    }
};

function getModeSettings() { return MODES[activeMode]; }

let playerScore = 0, opponentScore = 0;
let serveSide = 'player';
let gameState = 'menu';
let roundTimer = 0;
let gameMode = 'solo';
let pointScored = false;

let playerTouches = 0, opponentTouches = 0;
let lastTouchSide = null;

let peer = null, conn = null;
let isHost = false, lobbyCode = '';
let opponentSelectedMode = 'volleyball';

const keys = {};
let clickedThisFrame = false;
let rightClickDown = false;
let rightClickReleased = false;
let setPressed = false;
let remoteInput = { left: false, right: false, jump: false, set: false, click: false, rightClickDown: false, rightClickReleased: false };

// AI Learning System
const aiMemory = {
    playerPatterns: { avgHitPosX: 0.3, avgHitPosY: 0.5, spikeFrequency: 0.3, hitCount: 0 },
    adaptations: { reactionSpeed: 1, aggressiveness: 0.5, positioningBias: 0 }
};

function updateAILearning(event, data) {
    const m = aiMemory;
    if (event === 'playerHit') {
        m.playerPatterns.hitCount++;
        m.playerPatterns.avgHitPosX = (m.playerPatterns.avgHitPosX * (m.playerPatterns.hitCount - 1) + data.x / W) / m.playerPatterns.hitCount;
        if (data.isSpike) m.playerPatterns.spikeFrequency = m.playerPatterns.spikeFrequency * 0.9 + 0.1;
        else m.playerPatterns.spikeFrequency *= 0.95;
    } else if (event === 'aiMissed') {
        m.adaptations.reactionSpeed = Math.min(1.5, m.adaptations.reactionSpeed + 0.05);
    } else if (event === 'aiScored') {
        m.adaptations.aggressiveness = Math.min(0.8, m.adaptations.aggressiveness + 0.02);
    }
}

// ==================== CHAT ====================
function addChatMessage(text, type) {
    const messagesDiv = document.getElementById('chatMessages');
    const msg = document.createElement('div');
    msg.className = 'chat-message ' + type;
    msg.textContent = text;
    messagesDiv.appendChild(msg);
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
    if (messagesDiv.children.length > 50) messagesDiv.removeChild(messagesDiv.firstChild);
}

function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (text && conn && conn.open) {
        conn.send({ type: 'chat', message: text });
        addChatMessage(text, 'you');
        input.value = '';
    }
}

document.getElementById('chatSend').addEventListener('click', sendChatMessage);
document.getElementById('chatInput').addEventListener('keypress', e => { if (e.key === 'Enter') sendChatMessage(); });

// ==================== SOUND ====================
let audioCtx = null;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }

function playSound(type) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    const sounds = {
        set: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(500, now); osc.frequency.exponentialRampToValueAtTime(700, now + 0.1); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); osc.start(now); osc.stop(now + 0.15); },
        hit: () => { osc.type = activeMode === 'badminton' ? 'sine' : 'triangle'; osc.frequency.setValueAtTime(activeMode === 'badminton' ? 800 : 300, now); osc.frequency.exponentialRampToValueAtTime(400, now + 0.08); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); osc.start(now); osc.stop(now + 0.15); },
        smash: () => { osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.05); gain.gain.setValueAtTime(0.25, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.18); osc.start(now); osc.stop(now + 0.18); },
        score: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(523, now); osc.frequency.setValueAtTime(659, now + 0.12); osc.frequency.setValueAtTime(784, now + 0.24); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5); osc.start(now); osc.stop(now + 0.5); },
        lose: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(200, now + 0.3); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4); osc.start(now); osc.stop(now + 0.4); },
        bounce: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(activeMode === 'basketball' ? 150 : 300, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.08); gain.gain.setValueAtTime(0.12, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); osc.start(now); osc.stop(now + 0.1); },
        net: () => { osc.type = 'triangle'; osc.frequency.setValueAtTime(180, now); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.12); osc.start(now); osc.stop(now + 0.12); },
        whistle: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(800, now); osc.frequency.setValueAtTime(1000, now + 0.1); osc.frequency.setValueAtTime(800, now + 0.2); gain.gain.setValueAtTime(0.15, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35); osc.start(now); osc.stop(now + 0.35); },
        swish: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now); osc.frequency.exponentialRampToValueAtTime(600, now + 0.2); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25); osc.start(now); osc.stop(now + 0.25); },
        dunk: () => { osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.setValueAtTime(200, now + 0.05); gain.gain.setValueAtTime(0.3, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); osc.start(now); osc.stop(now + 0.2); },
        charge: () => { osc.type = 'sine'; osc.frequency.setValueAtTime(300, now); gain.gain.setValueAtTime(0.05, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05); osc.start(now); osc.stop(now + 0.05); }
    };
    if (sounds[type]) sounds[type]();
}

// ==================== SCREENS ====================
function showScreen(screenId) {
    document.querySelectorAll('.screen').forEach(s => s.style.display = 'none');
    document.getElementById('gameContainer').style.display = 'none';
    if (screenId === 'game') document.getElementById('gameContainer').style.display = 'flex';
    else document.getElementById(screenId).style.display = 'flex';
}

function exitToMenu() {
    if (confirm('Leave the game?')) {
        cleanupPeer();
        gameState = 'menu';
        showScreen('menuScreen');
    }
}

// ==================== SETTINGS ====================
document.getElementById('gameModeGroup').addEventListener('click', e => {
    const option = e.target.closest('.radio-option');
    if (option) {
        document.querySelectorAll('.radio-option').forEach(o => o.classList.remove('selected'));
        option.classList.add('selected');
        selectedMode = option.dataset.mode;
        localStorage.setItem('gameMode', selectedMode);
    }
});

const savedMode = localStorage.getItem('gameMode');
if (savedMode && MODES[savedMode]) {
    selectedMode = savedMode;
    document.querySelectorAll('.radio-option').forEach(o => o.classList.toggle('selected', o.dataset.mode === selectedMode));
}

// ==================== MULTIPLAYER ====================
function generateCode() {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
    return Array(5).fill().map(() => chars[Math.floor(Math.random() * chars.length)]).join('');
}

function createLobby() {
    lobbyCode = generateCode();
    document.getElementById('lobbyCode').textContent = lobbyCode;
    document.getElementById('waitingStatus').innerHTML = 'Waiting for opponent<span class="loading-dots"></span>';
    showScreen('waitingScreen');
    
    peer = new Peer('vball-' + lobbyCode);
    peer.on('open', () => console.log('Lobby created'));
    peer.on('connection', connection => {
        conn = connection;
        isHost = true;
        gameMode = 'host';
        conn.on('open', () => setupConnectionHandlers());
        conn.on('data', handleNetworkData);
    });
    peer.on('error', err => {
        if (err.type === 'unavailable-id') {
            document.getElementById('waitingStatus').innerHTML = '<span class="error-text">Code taken, retrying...</span>';
            setTimeout(() => { cleanupPeer(); createLobby(); }, 1000);
        } else {
            document.getElementById('waitingStatus').innerHTML = '<span class="error-text">Error: ' + err.type + '</span>';
        }
    });
}

function joinLobby() {
    const code = document.getElementById('lobbyInput').value.toUpperCase().trim();
    if (code.length < 3) {
        document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Please enter a valid code</span>';
        return;
    }
    
    document.getElementById('lobbyStatus').innerHTML = 'Connecting<span class="loading-dots"></span>';
    document.getElementById('connectBtn').disabled = true;
    
    peer = new Peer();
    peer.on('open', () => {
        conn = peer.connect('vball-' + code, { reliable: true });
        conn.on('open', () => {
            isHost = false;
            gameMode = 'client';
            setupConnectionHandlers();
            conn.send({ type: 'ready', selectedMode });
        });
        conn.on('data', handleNetworkData);
        conn.on('error', () => {
            document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Connection failed</span>';
            document.getElementById('connectBtn').disabled = false;
        });
    });
    peer.on('error', () => {
        document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Lobby not found</span>';
        document.getElementById('connectBtn').disabled = false;
    });
    
    setTimeout(() => {
        if (!conn || !conn.open) {
            document.getElementById('lobbyStatus').innerHTML = '<span class="error-text">Connection timeout</span>';
            document.getElementById('connectBtn').disabled = false;
        }
    }, 10000);
}

function setupConnectionHandlers() { conn.on('close', () => { alert('Opponent disconnected'); location.reload(); }); }

function handleNetworkData(data) {
    if (data.type === 'ready' && isHost) { opponentSelectedMode = data.selectedMode; startMultiplayerGame(); }
    else if (data.type === 'start' && !isHost) { opponentSelectedMode = data.selectedMode; activeMode = (selectedMode === opponentSelectedMode) ? selectedMode : 'volleyball'; beginGame(); }
    else if (data.type === 'state' && !isHost) {
        player.x = W - data.opponent.x - player.w; player.y = data.opponent.y;
        player.handAction = data.opponent.handAction || 'idle'; player.handTimer = data.opponent.handTimer || 0;
        player.shootPower = data.opponent.shootPower || 0; player.isCharging = data.opponent.isCharging || false;
        opponent.x = W - data.player.x - opponent.w; opponent.y = data.player.y;
        opponent.handAction = data.player.handAction || 'idle'; opponent.handTimer = data.player.handTimer || 0;
        opponent.shootPower = data.player.shootPower || 0; opponent.isCharging = data.player.isCharging || false;
        ball.x = W - data.ball.x; ball.y = data.ball.y; ball.vx = -data.ball.vx; ball.vy = data.ball.vy;
        playerScore = data.opponentScore; opponentScore = data.playerScore;
        playerTouches = data.opponentTouches; opponentTouches = data.playerTouches;
        gameState = data.gameState;
        updateScoreDisplay();
    }
    else if (data.type === 'input' && isHost) remoteInput = data.input;
    else if (data.type === 'sound') playSound(data.sound);
    else if (data.type === 'chat') addChatMessage(data.message, 'opponent');
}

function sendState() {
    if (conn && conn.open && isHost) {
        conn.send({
            type: 'state',
            player: { x: player.x, y: player.y, handAction: player.handAction, handTimer: player.handTimer, shootPower: player.shootPower, isCharging: player.isCharging },
            opponent: { x: opponent.x, y: opponent.y, handAction: opponent.handAction, handTimer: opponent.handTimer, shootPower: opponent.shootPower, isCharging: opponent.isCharging },
            ball: { x: ball.x, y: ball.y, vx: ball.vx, vy: ball.vy },
            playerScore, opponentScore, playerTouches, opponentTouches, gameState
        });
    }
}

function sendInput() {
    if (conn && conn.open && !isHost) {
        conn.send({ type: 'input', input: { left: keys['a'], right: keys['d'], jump: keys['w'] || keys[' '], set: setPressed, click: clickedThisFrame, rightClickDown, rightClickReleased } });
    }
}

function startMultiplayerGame() {
    activeMode = (selectedMode === opponentSelectedMode) ? selectedMode : 'volleyball';
    conn.send({ type: 'start', selectedMode });
    beginGame();
}

function beginGame() {
    const mode = getModeSettings();
    let modeText = isHost ? 'üü¢ Hosting' : (gameMode === 'client' ? 'üîµ Connected' : 'vs AI');
    const icons = { volleyball: 'üèê', tennis: 'üéæ', badminton: 'üè∏', basketball: 'üèÄ' };
    document.getElementById('mode-indicator').innerHTML = modeText + ` <span class="mode-badge ${activeMode}">${icons[activeMode]} ${activeMode.toUpperCase()}</span>`;
    
    document.getElementById('chatMessages').innerHTML = '';
    if (gameMode !== 'solo' && selectedMode !== opponentSelectedMode) {
        addChatMessage(`Mode mismatch! Defaulting to Volleyball`, 'system');
    }
    addChatMessage(`Playing ${activeMode}!`, 'system');
    
    const controls = {
        volleyball: 'A/D = move | W/SPACE = jump | Q = set | CLICK = bump | JUMP+CLICK = spike',
        tennis: 'A/D = move | W/SPACE = jump | CLICK = hit | JUMP+CLICK = smash',
        badminton: 'A/D = move | W/SPACE = jump | CLICK = hit | JUMP+CLICK = smash',
        basketball: 'A/D = move | W/SPACE = jump | CLICK = dribble | HOLD RIGHT CLICK = shoot | JUMP near hoop = DUNK'
    };
    document.getElementById('info').textContent = controls[activeMode];
    
    aiMemory.adaptations.reactionSpeed = Math.max(1, aiMemory.adaptations.reactionSpeed * 0.8);
    
    initAudio();
    playSound('whistle');
    showScreen('game');
    gameState = 'playing';
    playerScore = 0;
    opponentScore = 0;
    resetRound();
}

function cleanupPeer() {
    if (conn) conn.close();
    if (peer) peer.destroy();
    conn = null; peer = null;
}

// ==================== INPUT ====================
document.addEventListener('keydown', e => {
    if (document.activeElement.tagName === 'INPUT') return;
    keys[e.key.toLowerCase()] = true;
    if (e.key.toLowerCase() === 'q') setPressed = true;
    if (e.key === 'Escape' && (gameState === 'playing' || gameState === 'roundOver')) exitToMenu();
    if (gameState === 'playing' || gameState === 'roundOver') e.preventDefault();
});

document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

canvas.addEventListener('mousedown', e => {
    initAudio();
    if (e.button === 0) clickedThisFrame = true;
    else if (e.button === 2) rightClickDown = true;
});

canvas.addEventListener('mouseup', e => {
    if (e.button === 2) {
        rightClickDown = false;
        rightClickReleased = true;
    }
});

canvas.addEventListener('contextmenu', e => e.preventDefault());

document.getElementById('createBtn').addEventListener('click', () => { initAudio(); createLobby(); });
document.getElementById('joinBtn').addEventListener('click', () => {
    initAudio();
    document.getElementById('lobbyStatus').textContent = '';
    document.getElementById('lobbyInput').value = '';
    document.getElementById('connectBtn').disabled = false;
    showScreen('lobbyScreen');
    setTimeout(() => document.getElementById('lobbyInput').focus(), 100);
});
document.getElementById('soloBtn').addEventListener('click', () => { initAudio(); gameMode = 'solo'; activeMode = selectedMode; beginGame(); });
document.getElementById('settingsBtn').addEventListener('click', () => showScreen('settingsScreen'));
document.getElementById('settingsBackBtn').addEventListener('click', () => showScreen('menuScreen'));
document.getElementById('connectBtn').addEventListener('click', () => { initAudio(); joinLobby(); });
document.getElementById('lobbyBackBtn').addEventListener('click', () => { cleanupPeer(); showScreen('menuScreen'); });
document.getElementById('waitingBackBtn').addEventListener('click', () => { cleanupPeer(); showScreen('menuScreen'); });
document.getElementById('exitGameBtn').addEventListener('click', exitToMenu);
document.getElementById('lobbyInput').addEventListener('keypress', e => { if (e.key === 'Enter') { initAudio(); joinLobby(); } });

// ==================== ENTITIES ====================
const player = {
    x: 150, y: GROUND_Y - 55, w: 55, h: 55,
    vx: 0, vy: 0, speed: 4.5, jumpPower: -11,
    onGround: true, facingRight: true,
    handAction: 'idle', handTimer: 0,
    hasBall: false,
    shootPower: 0, isCharging: false, shootDirection: 1,
    lastChargeSound: 0
};

const opponent = {
    x: W - 220, y: GROUND_Y - 55, w: 55, h: 55,
    vx: 0, vy: 0, speed: 4, jumpPower: -11,
    onGround: true,
    actionCooldown: 0, hitCount: 0, targetX: W * 0.75,
    lastDecision: 0,
    handAction: 'idle', handTimer: 0,
    hasBall: false,
    shootPower: 0, isCharging: false, shootDirection: 1
};

const ball = {
    x: 200, y: 150, r: 16,
    vx: 0, vy: 0,
    lastHitBy: null, bounceCount: 0,
    holder: null
};

// Basketball hoops
const hoops = {
    left: { x: 50, y: GROUND_Y - 160, width: 50, rimY: GROUND_Y - 130 },
    right: { x: W - 100, y: GROUND_Y - 160, width: 50, rimY: GROUND_Y - 130 }
};

// ==================== HAND ANIMATION ====================
function triggerHandAction(entity, action) {
    entity.handAction = action;
    entity.handTimer = action === 'idle' ? 0 : 18;
}

function updateHands(entity) {
    if (entity.handTimer > 0) {
        entity.handTimer--;
        if (entity.handTimer <= 0) entity.handAction = 'idle';
    }
}

function getHandPositions(entity, facingLeft) {
    const cx = entity.x + entity.w / 2;
    const cy = entity.y + entity.h / 2;
    const action = entity.handAction;
    const t = entity.handTimer;
    const dir = facingLeft ? -1 : 1;
    
    let leftHand = { x: cx - 28 * dir, y: cy + 8, angle: 0 };
    let rightHand = { x: cx + 28 * dir, y: cy + 8, angle: 0 };
    
    if (action === 'set') {
        const lift = Math.sin((18 - t) / 18 * Math.PI) * 22;
        leftHand = { x: cx - 12, y: entity.y - 3 - lift, angle: -0.3 };
        rightHand = { x: cx + 12, y: entity.y - 3 - lift, angle: 0.3 };
    } else if (action === 'hit') {
        const swing = Math.sin((18 - t) / 18 * Math.PI);
        leftHand = { x: cx - 20 * dir + 15 * dir * swing, y: cy - 5, angle: swing * 0.5 * dir };
        rightHand = { x: cx + 20 * dir * swing, y: cy - 8 + swing * 12, angle: swing * 1.2 * dir };
    } else if (action === 'smash' || action === 'dunk') {
        const phase = (18 - t) / 18;
        if (phase < 0.25) {
            const lift = phase / 0.25;
            leftHand = { x: cx - 8, y: entity.y - 8 - lift * 25, angle: -0.2 };
            rightHand = { x: cx + 8, y: entity.y - 8 - lift * 28, angle: 0.2 };
        } else {
            const swing = (phase - 0.25) / 0.75;
            leftHand = { x: cx + 25 * dir * swing, y: entity.y - 33 + swing * 50, angle: swing * 1.5 * dir };
            rightHand = { x: cx + 35 * dir * swing, y: entity.y - 36 + swing * 55, angle: swing * 2 * dir };
        }
    } else if (action === 'shoot') {
        const phase = (18 - t) / 18;
        rightHand = { x: cx + 10 * dir, y: entity.y - 15 - phase * 25, angle: -0.3 * dir + phase * 1.2 * dir };
        leftHand = { x: cx - 8 * dir, y: entity.y + 5 - phase * 8, angle: 0 };
    } else if (action === 'charge') {
        rightHand = { x: cx + 5 * dir, y: entity.y - 20, angle: -0.5 * dir };
        leftHand = { x: cx - 10 * dir, y: entity.y + 5, angle: 0.2 * dir };
    } else if (action === 'dribble') {
        const bounce = Math.sin((18 - t) / 18 * Math.PI * 3);
        rightHand = { x: cx + 20 * dir, y: cy + 15 + bounce * 8, angle: 0.3 * dir };
    }
    
    return { left: leftHand, right: rightHand };
}

// ==================== GAME LOGIC ====================
function updateScoreDisplay() {
    document.getElementById('score').textContent = playerScore + ' - ' + opponentScore;
    const mode = getModeSettings();
    let touchText = '';
    if (activeMode === 'volleyball') touchText = `Touches: You ${playerTouches}/${mode.maxTouches} | Opp ${opponentTouches}/${mode.maxTouches}`;
    else if (activeMode === 'basketball') touchText = `First to 21`;
    else if (mode.allowBounce) touchText = `Bounces: ${ball.bounceCount}/1`;
    document.getElementById('touchIndicator').textContent = touchText;
}

function resetRound() {
    const mode = getModeSettings();
    
    player.x = activeMode === 'basketball' ? 150 : 180;
    player.y = GROUND_Y - player.h; player.vx = 0; player.vy = 0; player.onGround = true;
    player.handAction = 'idle'; player.handTimer = 0; player.hasBall = false;
    player.shootPower = 0; player.isCharging = false; player.shootDirection = 1;
    
    opponent.x = activeMode === 'basketball' ? W - 205 : W - 240;
    opponent.y = GROUND_Y - opponent.h; opponent.vx = 0; opponent.vy = 0; opponent.onGround = true;
    opponent.actionCooldown = 0; opponent.hitCount = 0; opponent.lastDecision = 0;
    opponent.handAction = 'idle'; opponent.handTimer = 0; opponent.hasBall = false;
    opponent.shootPower = 0; opponent.isCharging = false; opponent.shootDirection = 1;

    ball.vy = 0; ball.vx = 0;
    ball.lastHitBy = null; ball.bounceCount = 0; ball.holder = null;
    ball.r = mode.ballSize;
    
    playerTouches = 0; opponentTouches = 0;
    lastTouchSide = null;
    pointScored = false;
    
    if (activeMode === 'basketball') {
        ball.x = W / 2;
        ball.y = 100;
    } else if (serveSide === 'player') {
        ball.x = 220; ball.y = 140;
    } else {
        ball.x = W - 220; ball.y = 140;
    }
    
    gameState = 'playing';
    roundTimer = 0;
    updateScoreDisplay();
}

function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
function dist(x1, y1, x2, y2) { return Math.sqrt((x1-x2)**2 + (y1-y2)**2); }
function ballCenter(rect) { return dist(rect.x + rect.w/2, rect.y + rect.h/2, ball.x, ball.y); }

function capBallSpeed(maxSpd) {
    let spd = Math.sqrt(ball.vx**2 + ball.vy**2);
    if (spd > maxSpd) { ball.vx = (ball.vx / spd) * maxSpd; ball.vy = (ball.vy / spd) * maxSpd; }
}

function registerTouch(isPlayer) {
    if (gameState !== 'playing' || pointScored) return false;
    if (activeMode === 'basketball') return true;
    
    const mode = getModeSettings();
    const side = isPlayer ? 'player' : 'opponent';
    
    if (lastTouchSide !== side) {
        if (isPlayer) playerTouches = 1; else opponentTouches = 1;
        lastTouchSide = side;
    } else {
        if (isPlayer) playerTouches++; else opponentTouches++;
    }
    
    ball.bounceCount = 0;
    updateScoreDisplay();
    
    if (isPlayer && playerTouches > mode.maxTouches) return false;
    if (!isPlayer && opponentTouches > mode.maxTouches) return false;
    return true;
}

function doSet(rect, direction) {
    if (gameState !== 'playing' || pointScored || activeMode === 'basketball') return false;
    if (activeMode !== 'volleyball') return doHit(rect, direction);
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    if (!registerTouch(isPlayer)) { scorePoint(!isPlayer); return false; }
    
    triggerHandAction(rect, 'set');
    ball.vx = direction * 1.5; ball.vy = -10;
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    playSound('set');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'set' });
    return true;
}

function doHit(rect, direction) {
    if (gameState !== 'playing' || pointScored) return false;
    if (activeMode === 'basketball') return doDribble(rect);
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    if (!registerTouch(isPlayer)) { scorePoint(!isPlayer); return false; }
    
    if (isPlayer) updateAILearning('playerHit', { x: ball.x, y: ball.y, isSpike: false });
    
    triggerHandAction(rect, 'hit');
    
    if (activeMode === 'badminton') {
        ball.vx = direction * 11; ball.vy = -10;
    } else {
        ball.vx = direction * 7; ball.vy = -8;
    }
    
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    capBallSpeed(activeMode === 'badminton' ? 15 : 12);
    playSound('hit');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'hit' });
    return true;
}

function doSmash(rect, direction) {
    if (gameState !== 'playing' || pointScored) return false;
    if (activeMode === 'basketball') return false;
    if (ballCenter(rect) > HIT_RANGE) return false;
    
    const isPlayer = rect === player;
    const mode = getModeSettings();
    
    if (!registerTouch(isPlayer)) { scorePoint(!isPlayer); return false; }
    
    if (isPlayer) updateAILearning('playerHit', { x: ball.x, y: ball.y, isSpike: true });
    
    triggerHandAction(rect, 'smash');
    
    const netTop = GROUND_Y - mode.netHeight;
    if (activeMode === 'badminton') {
        ball.vx = direction * 15;
        ball.vy = ball.y < netTop - 40 ? 5 : -1;
    } else {
        ball.vx = direction * (10 + Math.min(Math.abs(ball.x - NET_X) / 50, 3));
        ball.vy = 3 + (ball.y < netTop ? 3 : 1);
    }
    
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    capBallSpeed(activeMode === 'badminton' ? 18 : 14);
    playSound('smash');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'smash' });
    return true;
}

// Basketball functions
function doDribble(rect) {
    if (ball.holder === rect) return true;
    if (ballCenter(rect) > HIT_RANGE + 30) return false;
    
    const isPlayer = rect === player;
    const otherHolder = isPlayer ? opponent : player;
    
    if (ball.holder === otherHolder) {
        if (Math.random() > 0.5) {
            otherHolder.hasBall = false;
            otherHolder.isCharging = false;
            otherHolder.shootPower = 0;
            ball.holder = rect;
            rect.hasBall = true;
            triggerHandAction(rect, 'dribble');
            playSound('hit');
            return true;
        }
        return false;
    }
    
    if (!ball.holder) {
        ball.holder = rect;
        rect.hasBall = true;
        triggerHandAction(rect, 'dribble');
        playSound('bounce');
    }
    return true;
}

function canDunk(entity) {
    if (!entity.hasBall || ball.holder !== entity) return false;
    if (entity.onGround) return false;
    
    const isPlayer = entity === player;
    const targetHoop = isPlayer ? hoops.right : hoops.left;
    
    const distToHoop = Math.abs((entity.x + entity.w / 2) - (targetHoop.x + targetHoop.width / 2));
    const heightCheck = entity.y < targetHoop.rimY + 30;
    
    return distToHoop < 70 && heightCheck;
}

function doDunk(entity) {
    if (!canDunk(entity)) return false;
    
    const isPlayer = entity === player;
    const targetHoop = isPlayer ? hoops.right : hoops.left;
    
    triggerHandAction(entity, 'dunk');
    entity.hasBall = false;
    ball.holder = null;
    
    ball.x = targetHoop.x + targetHoop.width / 2;
    ball.y = targetHoop.rimY + 5;
    ball.vx = 0;
    ball.vy = 8;
    
    // Score immediately
    const points = 2;
    if (isPlayer) playerScore += points;
    else opponentScore += points;
    
    playSound('dunk');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'dunk' });
    updateScoreDisplay();
    
    if (playerScore >= 21 || opponentScore >= 21) {
        setTimeout(() => scorePoint(playerScore >= 21), 500);
    } else {
        setTimeout(() => {
            if (gameState === 'playing') {
                ball.x = W / 2; ball.y = 100;
                ball.vx = 0; ball.vy = 0;
                ball.holder = null;
                player.hasBall = false;
                opponent.hasBall = false;
            }
        }, 1000);
    }
    
    return true;
}

function updateShootCharge(entity, isCharging) {
    if (!entity.hasBall || activeMode !== 'basketball') {
        entity.isCharging = false;
        entity.shootPower = 0;
        return;
    }
    
    if (isCharging) {
        if (!entity.isCharging) {
            entity.isCharging = true;
            entity.shootPower = 0;
            entity.shootDirection = 1;
            entity.handAction = 'charge';
        }
        
        // Oscillate power
        entity.shootPower += 0.025 * entity.shootDirection;
        
        if (entity.shootPower >= 1) {
            entity.shootPower = 1;
            entity.shootDirection = -1;
        } else if (entity.shootPower <= 0) {
            entity.shootPower = 0;
            entity.shootDirection = 1;
        }
        
        // Sound feedback at intervals
        if (Math.floor(entity.shootPower * 20) !== entity.lastChargeSound) {
            entity.lastChargeSound = Math.floor(entity.shootPower * 20);
            if (entity.shootPower > 0.9) playSound('charge');
        }
    }
}

function doShoot(entity) {
    if (!entity.hasBall || ball.holder !== entity || !entity.isCharging) return false;
    
    const power = entity.shootPower;
    entity.isCharging = false;
    entity.shootPower = 0;
    
    triggerHandAction(entity, 'shoot');
    entity.hasBall = false;
    ball.holder = null;
    
    const isPlayer = entity === player;
    const targetHoop = isPlayer ? hoops.right : hoops.left;
    const dx = targetHoop.x + targetHoop.width / 2 - ball.x;
    const dy = targetHoop.rimY - ball.y;
    
    // Calculate accuracy based on power (1.0 = perfect, lower = worse)
    let accuracy;
    if (power >= 0.95) accuracy = 1.0;
    else if (power >= 0.8) accuracy = 0.85 + (power - 0.8) * 0.5;
    else if (power >= 0.5) accuracy = 0.6 + (power - 0.5) * 0.83;
    else accuracy = 0.3 + power * 0.6;
    
    // Add randomness based on accuracy
    const errorX = (1 - accuracy) * (Math.random() - 0.5) * 150;
    const errorY = (1 - accuracy) * (Math.random() - 0.5) * 50;
    
    const targetX = targetHoop.x + targetHoop.width / 2 + errorX;
    const targetY = targetHoop.rimY + errorY;
    
    const distToTarget = Math.sqrt((targetX - ball.x)**2 + (targetY - ball.y)**2);
    const arcHeight = Math.max(100, distToTarget * 0.5);
    const time = distToTarget / 9;
    
    ball.vx = (targetX - ball.x) / time;
    ball.vy = -arcHeight / time * 1.5;
    ball.lastHitBy = isPlayer ? 'player' : 'opponent';
    
    playSound('hit');
    if (conn && conn.open && isHost) conn.send({ type: 'sound', sound: 'hit' });
    return true;
}

function checkBasketScore() {
    [{ hoop: hoops.left, scorer: 'opponent' }, { hoop: hoops.right, scorer: 'player' }].forEach(({ hoop, scorer }) => {
        if (ball.x > hoop.x + 5 && ball.x < hoop.x + hoop.width - 5 &&
            ball.y > hoop.rimY - 5 && ball.y < hoop.rimY + 20 &&
            ball.vy > 0 && !pointScored) {
            
            const distFromCenter = Math.abs(ball.x - (hoop.x + hoop.width / 2));
            if (distFromCenter < hoop.width * 0.35) {
                const shooterX = scorer === 'player' ? player.x : opponent.x;
                const distance = Math.abs(ball.x - shooterX);
                const points = distance > 280 ? 3 : 2;
                
                if (scorer === 'player') playerScore += points;
                else opponentScore += points;
                
                playSound('swish');
                updateScoreDisplay();
                
                ball.vy *= 0.3;
                ball.vx *= 0.3;
                
                if (playerScore >= 21 || opponentScore >= 21) {
                    setTimeout(() => scorePoint(playerScore >= 21), 500);
                } else {
                    setTimeout(() => {
                        if (gameState === 'playing' && !pointScored) {
                            ball.x = W / 2; ball.y = 100;
                            ball.vx = 0; ball.vy = 0;
                            ball.holder = null;
                            player.hasBall = false;
                            opponent.hasBall = false;
                            player.isCharging = false;
                            opponent.isCharging = false;
                        }
                    }, 1200);
                }
            }
        }
    });
}

function rectCircleCollision(rx, ry, rw, rh, cx, cy, cr) {
    let closestX = clamp(cx, rx, rx + rw);
    let closestY = clamp(cy, ry, ry + rh);
    return dist(cx, cy, closestX, closestY) < cr;
}

function pushBallOutOfRect(rect) {
    let closestX = clamp(ball.x, rect.x, rect.x + rect.w);
    let closestY = clamp(ball.y, rect.y, rect.y + rect.h);
    let dx = ball.x - closestX, dy = ball.y - closestY;
    let d = Math.sqrt(dx*dx + dy*dy) || 1;
    let overlap = ball.r - d;
    if (overlap > 0) { ball.x += (dx / d) * (overlap + 1); ball.y += (dy / d) * (overlap + 1); }
}

// ==================== PLAYER ====================
function updatePlayer() {
    updateHands(player);
    
    player.vx = 0;
    if (keys['a']) { player.vx = -player.speed; player.facingRight = false; }
    if (keys['d']) { player.vx = player.speed; player.facingRight = true; }
    if ((keys['w'] || keys[' ']) && player.onGround) {
        player.vy = player.jumpPower;
        player.onGround = false;
    }

    if (activeMode === 'basketball') {
        // Check for dunk opportunity
        if (!player.onGround && player.hasBall && canDunk(player)) {
            if (clickedThisFrame || (keys['w'] || keys[' '])) {
                doDunk(player);
            }
        }
        
        // Shooting charge
        updateShootCharge(player, rightClickDown);
        
        // Release shot
        if (rightClickReleased && player.isCharging) {
            doShoot(player);
        }
        
        // Dribble/steal
        if (clickedThisFrame && !canDunk(player)) {
            doDribble(player);
        }
    } else {
        if (setPressed && activeMode === 'volleyball' && gameState === 'playing') {
            setPressed = false;
            doSet(player, 1);
        }

        if (clickedThisFrame && gameState === 'playing') {
            if (!player.onGround && ball.y < player.y + 20) {
                doSmash(player, 1);
            } else {
                doHit(player, 1);
            }
        }
    }

    player.vy += GRAVITY;
    player.x += player.vx;
    player.y += player.vy;

    if (player.y + player.h >= GROUND_Y) {
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        player.onGround = true;
    }
    
    if (activeMode === 'basketball') {
        player.x = clamp(player.x, 0, W - player.w);
    } else {
        player.x = clamp(player.x, 0, NET_X - player.w - 8);
    }
    
    if (player.hasBall && ball.holder === player && !player.isCharging) {
        ball.x = player.x + player.w / 2 + (player.facingRight ? 20 : -20);
        ball.y = player.y + player.h - 10 + Math.sin(Date.now() / 80) * 8;
        ball.vx = 0; ball.vy = 0;
    } else if (player.hasBall && ball.holder === player && player.isCharging) {
        ball.x = player.x + player.w / 2 + (player.facingRight ? 8 : -8);
        ball.y = player.y - 15;
        ball.vx = 0; ball.vy = 0;
    }
}

// ==================== OPPONENT ====================
function updateOpponent() {
    updateHands(opponent);
    
    if (gameMode === 'host') {
        opponent.vx = 0;
        if (remoteInput.left) opponent.vx = opponent.speed;
        if (remoteInput.right) opponent.vx = -opponent.speed;
        if (remoteInput.jump && opponent.onGround) { opponent.vy = opponent.jumpPower; opponent.onGround = false; }
        
        if (activeMode === 'basketball') {
            if (!opponent.onGround && opponent.hasBall && canDunk(opponent)) {
                if (remoteInput.click) doDunk(opponent);
            }
            updateShootCharge(opponent, remoteInput.rightClickDown);
            if (remoteInput.rightClickReleased && opponent.isCharging) {
                doShoot(opponent);
                remoteInput.rightClickReleased = false;
            }
            if (remoteInput.click && !canDunk(opponent)) doDribble(opponent);
        } else {
            if (remoteInput.set && activeMode === 'volleyball' && gameState === 'playing') { remoteInput.set = false; doSet(opponent, -1); }
            if (remoteInput.click && gameState === 'playing') {
                remoteInput.click = false;
                if (!opponent.onGround && ball.y < opponent.y + 20) doSmash(opponent, -1);
                else doHit(opponent, -1);
            }
        }
    } else if (gameMode === 'solo') {
        updateAI();
    }

    if (gameMode !== 'client') {
        opponent.vy += GRAVITY;
        opponent.x += opponent.vx;
        opponent.y += opponent.vy;

        if (opponent.y + opponent.h >= GROUND_Y) {
            opponent.y = GROUND_Y - opponent.h;
            opponent.vy = 0;
            opponent.onGround = true;
        }
        
        if (activeMode === 'basketball') {
            opponent.x = clamp(opponent.x, 0, W - opponent.w);
        } else {
            opponent.x = clamp(opponent.x, NET_X + 8, W - opponent.w);
        }
    }
    
    if (opponent.hasBall && ball.holder === opponent && !opponent.isCharging) {
        ball.x = opponent.x + opponent.w / 2 - 20;
        ball.y = opponent.y + opponent.h - 10 + Math.sin(Date.now() / 80) * 8;
        ball.vx = 0; ball.vy = 0;
    } else if (opponent.hasBall && ball.holder === opponent && opponent.isCharging) {
        ball.x = opponent.x + opponent.w / 2 - 8;
        ball.y = opponent.y - 15;
        ball.vx = 0; ball.vy = 0;
    }
}

function updateAI() {
    if (gameState !== 'playing' || pointScored) { opponent.vx = 0; return; }
    
    const mode = getModeSettings();
    const adapt = aiMemory.adaptations;
    
    opponent.actionCooldown = Math.max(0, opponent.actionCooldown - 1);
    opponent.lastDecision++;

    if (activeMode === 'basketball') {
        updateAIBasketball();
        return;
    }

    const netTop = GROUND_Y - (mode.netHeight || 0);
    const ballOnMySide = ball.x > NET_X;
    const distToB = ballCenter(opponent);

    let predictX = ball.x, predictY = ball.y;
    let pvx = ball.vx, pvy = ball.vy;
    for (let i = 0; i < 70; i++) {
        pvy += mode.ballGravity;
        if (activeMode === 'badminton') pvx *= mode.shuttleDrag;
        predictX += pvx; predictY += pvy;
        if (predictY >= GROUND_Y - 20) break;
    }
    
    predictX += adapt.positioningBias * 30;

    const reactionDelay = Math.max(15, 30 - adapt.reactionSpeed * 10);
    if (opponent.lastDecision > reactionDelay) {
        opponent.lastDecision = 0;
        
        if (ballOnMySide) {
            if (adapt.aggressiveness > 0.5) opponent.targetX = ball.x - opponent.w / 2;
            else opponent.targetX = predictX - opponent.w / 2;
        } else {
            opponent.targetX = W * 0.72 + adapt.positioningBias * 20;
        }
    }

    opponent.targetX = clamp(opponent.targetX, NET_X + 12, W - opponent.w - 12);

    const diff = opponent.targetX - opponent.x;
    if (Math.abs(diff) > 6) {
        opponent.vx = (diff > 0 ? opponent.speed : -opponent.speed) * adapt.reactionSpeed;
    } else {
        opponent.vx = 0;
    }

    if (ballOnMySide && opponent.actionCooldown <= 0) {
        const ballComingDown = ball.vy > 0;
        const ballNear = distToB < HIT_RANGE + 25;
        const ballAbove = ball.y < opponent.y;
        const ballHigh = ball.y < netTop - 20;

        if (ballAbove && ballComingDown && distToB < 160 && opponent.onGround) {
            if (ball.y < netTop + 80) {
                opponent.vy = opponent.jumpPower * (0.95 + adapt.aggressiveness * 0.1);
                opponent.onGround = false;
            }
        }

        if (ballNear && (ballAbove || ball.y < opponent.y + 30)) {
            if (!opponent.onGround && ballHigh && ball.y < opponent.y + 40 && adapt.aggressiveness > 0.4) {
                if (doSmash(opponent, -1)) {
                    opponent.actionCooldown = 15;
                    opponent.hitCount = 0;
                    updateAILearning('aiScored', { type: 'spikes' });
                }
            } else if (activeMode === 'volleyball' && opponent.hitCount === 0 && ballComingDown) {
                if (doSet(opponent, -1)) {
                    opponent.actionCooldown = 8;
                    opponent.hitCount = 1;
                }
            } else if (ballComingDown) {
                if (doHit(opponent, -1)) {
                    opponent.actionCooldown = 12;
                    opponent.hitCount = 0;
                }
            }
        }

        if (ballNear && ball.y > netTop + 50 && ballComingDown) {
            if (doHit(opponent, -1)) opponent.actionCooldown = 15;
        }
    }

    if (!ballOnMySide) opponent.hitCount = 0;
}

function updateAIBasketball() {
    const distToB = ballCenter(opponent);
    
    // Check for dunk opportunity
    if (opponent.hasBall && !opponent.onGround && canDunk(opponent)) {
        doDunk(opponent);
        return;
    }
    
    if (opponent.hasBall && ball.holder === opponent) {
        const targetHoop = hoops.left;
        const distToHoop = dist(opponent.x + opponent.w/2, opponent.y, targetHoop.x + targetHoop.width/2, targetHoop.rimY);
        
        // Try to get closer for dunk
        const dunkZone = targetHoop.x + targetHoop.width + 60;
        const idealShootX = targetHoop.x + 200;
        
        if (opponent.x > dunkZone && distToHoop < 200) {
            // Move towards dunk zone
            const diff = dunkZone - 10 - opponent.x;
            opponent.vx = clamp(diff * 0.15, -opponent.speed, opponent.speed);
            
            // Jump for dunk when close
            if (Math.abs(diff) < 40 && opponent.onGround && opponent.actionCooldown <= 0) {
                opponent.vy = opponent.jumpPower;
                opponent.onGround = false;
                opponent.actionCooldown = 20;
            }
        } else {
            // Move to shooting position
            const diff = idealShootX - opponent.x;
            
            if (Math.abs(diff) > 30) {
                opponent.vx = clamp(diff * 0.1, -opponent.speed * 0.8, opponent.speed * 0.8);
            } else {
                opponent.vx = 0;
                
                // Shoot with charge
                if (opponent.actionCooldown <= 0 && distToHoop < 400) {
                    if (!opponent.isCharging) {
                        opponent.isCharging = true;
                        opponent.shootPower = 0;
                        opponent.shootDirection = 1;
                        opponent.handAction = 'charge';
                    } else {
                        // AI timing - try to release near perfect
                        opponent.shootPower += 0.03 * opponent.shootDirection;
                        if (opponent.shootPower >= 1) opponent.shootDirection = -1;
                        else if (opponent.shootPower <= 0) opponent.shootDirection = 1;
                        
                        // Release at good power
                        if (opponent.shootPower > 0.9 && opponent.shootDirection === -1) {
                            doShoot(opponent);
                            opponent.actionCooldown = 40;
                        }
                    }
                }
            }
        }
    } else {
        opponent.isCharging = false;
        opponent.shootPower = 0;
        
        // Chase ball
        const targetX = ball.x - opponent.w / 2;
        const diff = targetX - opponent.x;
        
        if (Math.abs(diff) > 15) {
            opponent.vx = clamp(diff * 0.12, -opponent.speed, opponent.speed);
        } else {
            opponent.vx = 0;
        }
        
        // Get ball
        if (distToB < HIT_RANGE + 30 && opponent.actionCooldown <= 0) {
            doDribble(opponent);
            opponent.actionCooldown = 10;
        }
        
        // Jump for high balls
        if (ball.y < opponent.y - 50 && distToB < 120 && opponent.onGround) {
            opponent.vy = opponent.jumpPower;
            opponent.onGround = false;
        }
    }
}

// ==================== BALL ====================
function updateBall() {
    if (gameMode === 'client' || gameState !== 'playing' || pointScored) return;
    if (ball.holder) return;

    const mode = getModeSettings();
    const netTop = GROUND_Y - (mode.netHeight || 0);

    ball.vy += mode.ballGravity;
    if (activeMode === 'badminton') ball.vx *= mode.shuttleDrag;
    ball.x += ball.vx;
    ball.y += ball.vy;

    capBallSpeed(18);

    // Walls
    if (ball.x - ball.r < 0) { ball.x = ball.r; ball.vx = Math.abs(ball.vx) * 0.7; playSound('bounce'); }
    if (ball.x + ball.r > W) { ball.x = W - ball.r; ball.vx = -Math.abs(ball.vx) * 0.7; playSound('bounce'); }
    if (ball.y - ball.r < 0) { ball.y = ball.r; ball.vy = Math.abs(ball.vy) * 0.7; playSound('bounce'); }

    // Net (not in basketball)
    if (activeMode !== 'basketball' && mode.netHeight > 0) {
        if (ball.y + ball.r > netTop && ball.y - ball.r < GROUND_Y) {
            if (ball.x - ball.r < NET_X + 5 && ball.x + ball.r > NET_X - 5) {
                playSound('net');
                if (ball.x < NET_X) { ball.x = NET_X - 5 - ball.r; ball.vx = -Math.abs(ball.vx) * 0.5; }
                else { ball.x = NET_X + 5 + ball.r; ball.vx = Math.abs(ball.vx) * 0.5; }
            }
        }
        if (ball.x > NET_X - 12 && ball.x < NET_X + 12 && ball.y + ball.r > netTop && ball.y < netTop + 8) {
            ball.y = netTop - ball.r;
            ball.vy = -Math.abs(ball.vy) * 0.4;
            playSound('net');
        }
    }

    // Basketball hoops collision
    if (activeMode === 'basketball') {
        checkBasketScore();
        
        [hoops.left, hoops.right].forEach(hoop => {
            // Backboard
            const backboardX = hoop === hoops.left ? hoop.x - 8 : hoop.x + hoop.width;
            if (ball.x + ball.r > backboardX - 5 && ball.x - ball.r < backboardX + 12 &&
                ball.y > hoop.y - 50 && ball.y < hoop.rimY + 10) {
                if (hoop === hoops.left) {
                    ball.x = backboardX - 5 - ball.r;
                    ball.vx = Math.abs(ball.vx) * 0.6;
                } else {
                    ball.x = backboardX + 12 + ball.r;
                    ball.vx = -Math.abs(ball.vx) * 0.6;
                }
                playSound('bounce');
            }
            
            // Rim
            const rimLeft = hoop.x;
            const rimRight = hoop.x + hoop.width;
            if (ball.y > hoop.rimY - 8 && ball.y < hoop.rimY + 12) {
                if (Math.abs(ball.x - rimLeft) < ball.r + 4) {
                    ball.vx = -Math.abs(ball.vx) * 0.5 - 1;
                    ball.vy = -Math.abs(ball.vy) * 0.4;
                    playSound('bounce');
                }
                if (Math.abs(ball.x - rimRight) < ball.r + 4) {
                    ball.vx = Math.abs(ball.vx) * 0.5 + 1;
                    ball.vy = -Math.abs(ball.vy) * 0.4;
                    playSound('bounce');
                }
            }
        });
    }

    // Side tracking
    if (activeMode !== 'basketball') {
        const currentSide = ball.x < NET_X ? 'player' : 'opponent';
        if (lastTouchSide && currentSide !== lastTouchSide) {
            if (currentSide === 'player') playerTouches = 0;
            else opponentTouches = 0;
            updateScoreDisplay();
        }
    }

    // Player collisions
    if (!ball.holder) {
        if (rectCircleCollision(player.x, player.y, player.w, player.h, ball.x, ball.y, ball.r)) {
            pushBallOutOfRect(player);
            if (activeMode === 'basketball') ball.vy *= 0.5;
            else ball.vy = Math.min(ball.vy, -2);
            playSound('bounce');
        }
        if (rectCircleCollision(opponent.x, opponent.y, opponent.w, opponent.h, ball.x, ball.y, ball.r)) {
            pushBallOutOfRect(opponent);
            if (activeMode === 'basketball') ball.vy *= 0.5;
            else ball.vy = Math.min(ball.vy, -2);
            playSound('bounce');
        }
    }

    // Ground
    if (ball.y + ball.r >= GROUND_Y) {
        if (mode.allowBounce) {
            if (activeMode === 'basketball') {
                ball.y = GROUND_Y - ball.r;
                ball.vy = -ball.vy * 0.7;
                ball.vx *= 0.9;
                playSound('bounce');
            } else if (ball.bounceCount < 1) {
                ball.bounceCount++;
                ball.y = GROUND_Y - ball.r;
                ball.vy = -ball.vy * 0.55;
                ball.vx *= 0.75;
                playSound('bounce');
                updateScoreDisplay();
            } else {
                const isPlayerSide = ball.x < NET_X;
                if (!isPlayerSide) updateAILearning('aiMissed', {});
                scorePoint(ball.x >= NET_X);
            }
        } else {
            const isPlayerSide = ball.x < NET_X;
            if (isPlayerSide) updateAILearning('aiScored', { type: 'points' });
            else updateAILearning('aiMissed', {});
            scorePoint(ball.x >= NET_X);
        }
    }
}

function scorePoint(playerScored) {
    if (pointScored || gameState !== 'playing') return;
    
    pointScored = true;
    gameState = 'roundOver';
    roundTimer = 100;
    ball.vy = 0; ball.vx = 0;
    ball.y = Math.min(ball.y, GROUND_Y - ball.r);
    ball.holder = null;
    player.hasBall = false;
    opponent.hasBall = false;
    player.isCharging = false;
    opponent.isCharging = false;

    if (activeMode !== 'basketball') {
        if (playerScored) { playerScore++; serveSide = 'opponent'; playSound('score'); }
        else { opponentScore++; serveSide = 'player'; playSound('lose'); }
    } else {
        if (playerScored) playSound('score');
        else playSound('lose');
    }
    updateScoreDisplay();
}

// ==================== DRAWING ====================
function drawPowerBar(entity) {
    if (!entity.isCharging || activeMode !== 'basketball') return;
    
    const barWidth = 10;
    const barHeight = 60;
    const x = entity.x + entity.w + 8;
    const y = entity.y + entity.h - barHeight;
    
    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(x - 2, y - 2, barWidth + 4, barHeight + 4);
    
    // Power level
    const fillHeight = entity.shootPower * barHeight;
    
    // Color based on power
    let color;
    if (entity.shootPower >= 0.95) color = '#00ff00';
    else if (entity.shootPower >= 0.8) color = '#88ff00';
    else if (entity.shootPower >= 0.5) color = '#ffff00';
    else color = '#ff6600';
    
    ctx.fillStyle = color;
    ctx.fillRect(x, y + barHeight - fillHeight, barWidth, fillHeight);
    
    // Perfect zone indicator
    ctx.fillStyle = 'rgba(0,255,0,0.3)';
    ctx.fillRect(x, y, barWidth, barHeight * 0.05);
    
    // Border
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, barWidth, barHeight);
    
    // "PERFECT" text when in zone
    if (entity.shootPower >= 0.95) {
        ctx.fillStyle = '#00ff00';
        ctx.font = 'bold 10px monospace';
        ctx.fillText('PERFECT!', x - 15, y - 8);
    }
}

function drawRacket(x, y, angle, color) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    
    ctx.fillStyle = '#8B4513';
    ctx.fillRect(-3, 0, 6, 18);
    
    ctx.fillStyle = color;
    ctx.beginPath();
    if (activeMode === 'badminton') ctx.ellipse(0, -12, 10, 14, 0, 0, Math.PI * 2);
    else ctx.ellipse(0, -10, 12, 12, 0, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 0.5;
    for (let i = -8; i <= 8; i += 4) {
        ctx.beginPath(); ctx.moveTo(i, -22); ctx.lineTo(i, -2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-10, -12 + i); ctx.lineTo(10, -12 + i); ctx.stroke();
    }
    
    ctx.restore();
}

function drawPlayer(entity, mode, facingLeft, label) {
    const hands = getHandPositions(entity, facingLeft);
    const handColor = entity === player ? mode.handColor : mode.opponentHandColor;
    const bodyColor = entity === player ? mode.playerColor : mode.opponentColor;
    const hasRacket = mode.hasRacket;
    
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(entity.x + entity.w/2, GROUND_Y + 2, entity.w * 0.4, 6, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Hands behind for some poses
    const behindPoses = ['set', 'charge'];
    const isBehind = behindPoses.includes(entity.handAction) || (entity.handAction === 'smash' && entity.handTimer > 13) || (entity.handAction === 'dunk' && entity.handTimer > 13);
    
    ctx.fillStyle = handColor;
    if (isBehind) {
        ctx.fillRect(hands.left.x - HAND_SIZE/2, hands.left.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
        if (hasRacket) drawRacket(hands.right.x, hands.right.y, hands.right.angle, mode.racketColor);
        else ctx.fillRect(hands.right.x - HAND_SIZE/2, hands.right.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
    }
    
    // Body
    ctx.fillStyle = bodyColor;
    ctx.fillRect(entity.x, entity.y, entity.w, entity.h);
    
    // Eye
    ctx.fillStyle = '#fff';
    if (facingLeft) {
        ctx.fillRect(entity.x + 9, entity.y + 14, 14, 14);
        ctx.fillStyle = '#000';
        ctx.fillRect(entity.x + 12, entity.y + 18, 5, 5);
    } else {
        ctx.fillRect(entity.x + 32, entity.y + 14, 14, 14);
        ctx.fillStyle = '#000';
        ctx.fillRect(entity.x + 38, entity.y + 18, 5, 5);
    }
    
    // Hands in front
    ctx.fillStyle = handColor;
    if (!isBehind) {
        ctx.fillRect(hands.left.x - HAND_SIZE/2, hands.left.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
        if (hasRacket) drawRacket(hands.right.x, hands.right.y, hands.right.angle, mode.racketColor);
        else ctx.fillRect(hands.right.x - HAND_SIZE/2, hands.right.y - HAND_SIZE/2, HAND_SIZE, HAND_SIZE);
    }
    
    // Label
    ctx.font = 'bold 14px monospace';
    ctx.fillStyle = entity === player ? '#fff' : '#fdd';
    ctx.fillText(label, entity.x + (facingLeft ? 16 : 8), entity.y - 10);
    
    // Power bar
    drawPowerBar(entity);
    
    // Dunk indicator
    if (activeMode === 'basketball' && entity.hasBall && canDunk(entity)) {
        ctx.fillStyle = '#ff0';
        ctx.font = 'bold 12px monospace';
        ctx.fillText('DUNK!', entity.x + 5, entity.y - 25);
    }
}

function drawHoop(hoop, side) {
    // Backboard
    const bx = side === 'left' ? hoop.x - 12 : hoop.x + hoop.width;
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.fillRect(bx, hoop.y - 55, 12, 70);
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.strokeRect(bx, hoop.y - 55, 12, 70);
    
    // Backboard square
    ctx.strokeStyle = '#ff4500';
    ctx.lineWidth = 2;
    ctx.strokeRect(bx + (side === 'left' ? 2 : -30), hoop.y - 35, 30, 25);
    
    // Rim
    ctx.strokeStyle = '#ff4500';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(hoop.x, hoop.rimY);
    ctx.lineTo(hoop.x + hoop.width, hoop.rimY);
    ctx.stroke();
    
    // Net
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
        const topX = hoop.x + i * (hoop.width / 5);
        const bottomX = hoop.x + hoop.width / 2 + (i - 2.5) * 8;
        ctx.beginPath();
        ctx.moveTo(topX, hoop.rimY);
        ctx.quadraticCurveTo(topX, hoop.rimY + 15, bottomX, hoop.rimY + 30);
        ctx.stroke();
    }
    
    // Pole
    ctx.fillStyle = '#555';
    const poleX = side === 'left' ? hoop.x - 18 : hoop.x + hoop.width + 6;
    ctx.fillRect(poleX, hoop.rimY - 10, 8, GROUND_Y - hoop.rimY + 10);
}

function drawGame() {
    const mode = getModeSettings();
    const netTop = GROUND_Y - (mode.netHeight || 0);

    // Sky
    const grad = ctx.createLinearGradient(0, 0, 0, H);
    grad.addColorStop(0, mode.skyColors[0]);
    grad.addColorStop(1, mode.skyColors[1]);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);

    // Ground
    ctx.fillStyle = mode.groundColor;
    ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
    
    // Court markings
    if (activeMode === 'basketball') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(W/2, GROUND_Y, 60, Math.PI, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(hoops.left.x + hoops.left.width/2, GROUND_Y, 180, Math.PI, 0);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(hoops.right.x + hoops.right.width/2, GROUND_Y, 180, Math.PI, 0);
        ctx.stroke();
        ctx.strokeRect(20, GROUND_Y - 90, 100, 90);
        ctx.strokeRect(W - 120, GROUND_Y - 90, 100, 90);
        
        drawHoop(hoops.left, 'left');
        drawHoop(hoops.right, 'right');
    } else if (activeMode === 'tennis') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(30, GROUND_Y);
        ctx.lineTo(W - 30, GROUND_Y);
        ctx.stroke();
    } else if (activeMode === 'badminton') {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(50, GROUND_Y, W - 100, 50);
    } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(0, GROUND_Y);
        ctx.lineTo(W, GROUND_Y);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    // Net
    if (activeMode !== 'basketball' && mode.netHeight > 0) {
        ctx.fillStyle = activeMode === 'badminton' ? '#555' : '#333';
        ctx.fillRect(NET_X - 4, netTop, 8, mode.netHeight);
        ctx.fillStyle = '#fff';
        ctx.fillRect(NET_X - 8, netTop - 5, 16, 10);
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        for (let ny = netTop + 12; ny < GROUND_Y; ny += 12) {
            ctx.beginPath();
            ctx.moveTo(NET_X - 4, ny);
            ctx.lineTo(NET_X + 4, ny);
            ctx.stroke();
        }
    }

    // Hit range indicator
    if (activeMode !== 'basketball') {
        const pDist = ballCenter(player);
        if (pDist < HIT_RANGE + 30 && gameState === 'playing') {
            ctx.beginPath();
            ctx.arc(player.x + player.w/2, player.y + player.h/2, HIT_RANGE, 0, Math.PI * 2);
            ctx.strokeStyle = pDist < HIT_RANGE ? 'rgba(255,255,100,0.4)' : 'rgba(255,255,255,0.15)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }

    // Draw players
    drawPlayer(player, mode, false, 'YOU');
    drawPlayer(opponent, mode, true, gameMode === 'solo' ? 'AI' : 'P2');

    // Ball shadow
    if (!ball.holder) {
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.beginPath();
        ctx.ellipse(ball.x, GROUND_Y + 2, ball.r * 0.7, 4, 0, 0, Math.PI * 2);
        ctx.fill();
    }

    // Ball
    if (activeMode === 'badminton') {
        const angle = Math.atan2(ball.vy, ball.vx);
        ctx.save();
        ctx.translate(ball.x, ball.y);
        ctx.rotate(angle);
        ctx.fillStyle = '#f5f5dc';
        ctx.beginPath();
        ctx.arc(0, 0, ball.r * 0.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.moveTo(-ball.r * 0.5, 0);
        ctx.lineTo(-ball.r * 2.2, -ball.r * 1.1);
        ctx.lineTo(-ball.r * 2.2, ball.r * 1.1);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ddd';
        ctx.stroke();
        ctx.restore();
    } else if (activeMode === 'basketball') {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = mode.ballColor;
        ctx.fill();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ball.x - ball.r, ball.y);
        ctx.lineTo(ball.x + ball.r, ball.y);
        ctx.moveTo(ball.x, ball.y - ball.r);
        ctx.lineTo(ball.x, ball.y + ball.r);
        ctx.arc(ball.x, ball.y, ball.r * 0.6, 0, Math.PI * 2);
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1.5;
        ctx.stroke();
    } else {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        ctx.fillStyle = mode.ballColor;
        ctx.fill();
        if (activeMode === 'tennis') {
            ctx.strokeStyle = '#9acd32';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.r * 0.55, -0.6, Math.PI + 0.6);
            ctx.stroke();
        } else {
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1.5;
            ctx.stroke();
        }
    }

    // Bounce indicator
    if (activeMode === 'tennis' && ball.bounceCount === 1 && gameState === 'playing') {
        ctx.textAlign = 'center';
        ctx.font = 'bold 14px monospace';
        ctx.fillStyle = '#ff6600';
        ctx.fillText('BOUNCE!', ball.x, ball.y - 28);
        ctx.textAlign = 'left';
    }

    // Round over
    if (gameState === 'roundOver') {
        ctx.textAlign = 'center';
        ctx.font = 'bold 32px monospace';
        ctx.fillStyle = 'rgba(0,0,0,0.5)';
        ctx.fillRect(W/2 - 180, H/2 - 80, 360, 80);

        if (activeMode === 'basketball') {
            ctx.fillStyle = playerScore >= 21 ? '#77ff77' : '#ff7777';
            ctx.fillText(playerScore >= 21 ? 'You Win!' : 'AI Wins!', W/2, H/2 - 42);
        } else if (ball.x < NET_X) {
            ctx.fillStyle = '#ff7777';
            ctx.fillText(gameMode === 'solo' ? 'AI Scores!' : 'P2 Scores!', W/2, H/2 - 42);
        } else {
            ctx.fillStyle = '#77ff77';
            ctx.fillText('You Score!', W/2, H/2 - 42);
        }
        ctx.font = '14px monospace';
        ctx.fillStyle = '#ddd';
        ctx.fillText('next round starting...', W/2, H/2 - 16);
        ctx.textAlign = 'left';
    }

    // Action hints
    if (gameState === 'playing') {
        ctx.textAlign = 'center';
        ctx.font = '13px monospace';
        ctx.fillStyle = 'rgba(255,255,220,0.95)';
        
        if (activeMode === 'basketball') {
            if (player.hasBall && canDunk(player)) {
                ctx.fillText('Press JUMP or CLICK to DUNK!', W/2, H - 12);
            } else if (player.hasBall) {
                ctx.fillText('HOLD RIGHT CLICK to charge shot - release at GREEN!', W/2, H - 12);
            } else if (ballCenter(player) < HIT_RANGE + 30) {
                ctx.fillText('CLICK to grab ball', W/2, H - 12);
            }
        } else {
            const pDist = ballCenter(player);
            if (pDist < HIT_RANGE) {
                if (!player.onGround) ctx.fillText('CLICK to SMASH!', W/2, H - 12);
                else if (activeMode === 'volleyball') ctx.fillText('Q = Set | CLICK = Bump', W/2, H - 12);
                else ctx.fillText('CLICK = Hit', W/2, H - 12);
            }
        }
        ctx.textAlign = 'left';
    }
}

// ==================== GAME LOOP ====================
let lastTime = 0;
const TICK_RATE = 1000 / 60;

function gameLoop(timestamp) {
    const delta = timestamp - lastTime;
    
    if (delta >= TICK_RATE) {
        lastTime = timestamp - (delta % TICK_RATE);
        
        if (gameState === 'playing' || gameState === 'roundOver') {
            updatePlayer();
            updateOpponent();
            updateBall();
            drawGame();

            if (gameMode === 'host') sendState();
            else if (gameMode === 'client') sendInput();

            if (gameState === 'roundOver') {
                roundTimer--;
                if (roundTimer <= 0) {
                    playSound('whistle');
                    resetRound();
                }
            }
        }

        clickedThisFrame = false;
        rightClickReleased = false;
        setPressed = false;
    }

    requestAnimationFrame(gameLoop);
}

document.getElementById('score').textContent = '0 - 0';
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
